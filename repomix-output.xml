This file is a merged representation of the entire codebase, combined into a single document by Repomix.

<file_summary>
This section contains a summary of this file.

<purpose>
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.
</purpose>

<file_format>
The content is organized as follows:
1. This summary section
2. Repository information
3. Directory structure
4. Repository files (if enabled)
5. Multiple file entries, each consisting of:
  - File path as an attribute
  - Full contents of the file
</file_format>

<usage_guidelines>
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.
</usage_guidelines>

<notes>
- Some files may have been excluded based on .gitignore rules and Repomix's configuration
- Binary files are not included in this packed representation. Please refer to the Repository Structure section for a complete list of file paths, including binary files
- Files matching patterns in .gitignore are excluded
- Files matching default ignore patterns are excluded
- Files are sorted by Git change count (files with more changes are at the bottom)
</notes>

</file_summary>

<directory_structure>
.mvn/
  wrapper/
    maven-wrapper.properties
src/
  main/
    java/
      com/
        atharv/
          Event_Ticket_Platform/
            Config/
              CorsConfig.java
              JwtAuthenticationConverter.java
              KeycloakAdminConfig.java
              SecurityConfig.java
            Controllers/
              AnalyticsController.java
              EventController.java
              GlobalExceptionHandler.java
              KeycloakRoleController.java
              KeycloakStaffController.java
              OrganiserDashboardController.java
              PublishEventController.java
              StaffValidationController.java
              TicketController.java
            Domain/
              DTO/
                AnalyticDtos/
                  EventAnalyticsDto.java
                  OrganiserCompleteAnalyticsDto.java
                  TicketTypeAnalyticsDto.java
                  TicketTypePerformanceDto.java
                  ValidatedAttendeeResponse.java
                ErrorDtos/
                  ErrorDto.java
                EventDtos/
                  CreateEventRequestDto.java
                  EventCreatedResponseDto.java
                  EventDtoForTicketPurchase.java
                  EventResponseDto.java
                  ListEventResponseDto.java
                  PublishEventDto.java
                  UpdatedEventResponseDto.java
                  UpdateEventRequestDto.java
                QrCodeDtos/
                  QrCodeDetails.java
                StaffDtos/
                  GenerateStaffRequestDto.java
                  GenerateStaffResponseDto.java
                  StaffCredentialsDto.java
                  StaffCredentialWithPasswordDto.java
                TicketDtos/
                  TicketPurchasedDetails.java
                  TicketPurchasedDto.java
                  TicketValidationResponseDto.java
                TicketTypeDto/
                  CreateTicketTypeRequestDto.java
                  ListEventTicketTypeResponseDto.java
                  TicketTypeCreatedResponseDto.java
                  TicketTypeDetails.java
                  TicketTypeDtoForTicketPurchase.java
                  TicketTypeRevenueDto.java
                  UpdatedTicketTypeResponseDto.java
                  UpdateTicketTypeRequestDto.java
                TicketValidationDtos/
                  EventValidationStatsDto.java
                  StaffValidationStatsDto.java
                  TicketTypeAttendanceDto.java
                  TicketValidationResponseDto.java
                  ValidationHistoryDto.java
              Entity/
                Event.java
                QrCode.java
                Staff.java
                Ticket.java
                TicketType.java
                TicketValidation.java
                User.java
              Enum/
                EventStatus.java
                EventType.java
                QrCodeStatus.java
                TicketStatus.java
                TicketValidationMethod.java
                TicketValidationStatus.java
              Mapper/
                EventMapper.java
                TicketMapper.java
              Requests/
                CreateEventRequest.java
                CreateTicketTypeRequest.java
            Exceptions/
              EventTicketExceptions.java
              QrCodeNotFoundException.java
              QrCodeNotGeneratedException.java
              ResourceNotFoundException.java
              TicketNotPurchasedException.java
              TicketSoldOutException.java
              UserNotFoundExceptions.java
            Filters/
              StaffValidationFilter.java
              UserProvisioningFilter.java
            Repository/
              EventRepo.java
              QrCodeRepo.java
              StaffRepo.java
              TicketsRepo.java
              TicketTypeRepo.java
              TicketValidationRepo.java
              UserRepo.java
            Service/
              ServiceImpl/
                AnalyticsService.java
                EventServiceImpl.java
                KeycloakRoleService.java
                KeycloakUserService.java
                OrganiserDashboardService.java
                QrServiceImpl.java
                StaffTicketValidationService.java
                TicketServiceImpl.java
                UserServiceImpl.java
                ValidationStatsService.java
              ServiceInterface/
                EventService.java
                QrService.java
                TicketService.java
                TicketTypeService.java
                UserService.java
            util/
              generatePublicQrCode.java
              UserFromJwt.java
            EventTicketPlatformApplication.java
    resources/
      application.properties
    Theory/
      Production-Theory/
        database-entity.txt
        Dtos
      @RestControllerAdvice.txt
      day 1.txt
      equals & hash.txt
      FlowOfProject.txt
      keycloak.txt
      mapstruct.txt
      OAuth2.txt
      Rest api architecture.md
      userProvisioning.txt
  test/
    java/
      com/
        atharv/
          Event_Ticket_Platform/
            EventTicketPlatformApplicationTests.java
.gitattributes
.gitignore
docker-compose.yml
mvnw
mvnw.cmd
pom.xml
</directory_structure>

<files>
This section contains the contents of the repository's files.

<file path=".mvn/wrapper/maven-wrapper.properties">
wrapperVersion=3.3.4
distributionType=only-script
distributionUrl=https://repo.maven.apache.org/maven2/org/apache/maven/apache-maven/3.9.11/apache-maven-3.9.11-bin.zip
</file>

<file path="src/main/java/com/atharv/Event_Ticket_Platform/Config/CorsConfig.java">
package com.atharv.Event_Ticket_Platform.Config;

import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.web.cors.CorsConfiguration;
import org.springframework.web.cors.CorsConfigurationSource;
import org.springframework.web.cors.UrlBasedCorsConfigurationSource;

import java.util.Arrays;
import java.util.List;

@Configuration
public class CorsConfig {
    @Bean
    public CorsConfigurationSource corsConfigurationSource() {
        CorsConfiguration config = new CorsConfiguration();

        // Allow your frontend origin
        config.setAllowedOrigins(Arrays.asList(
                "http://localhost:5173",
                "http://localhost:3000"  // Add other ports if needed
        ));

        // IMPORTANT: Allow ALL HTTP methods including OPTIONS, PATCH, etc.
        config.setAllowedMethods(Arrays.asList(
                "GET",
                "POST",
                "PUT",
                "PATCH",   // ‚Üê This was missing!
                "DELETE",
                "OPTIONS", // ‚Üê This is critical for preflight
                "HEAD"
        ));

        // Allow all headers from the client
        config.setAllowedHeaders(Arrays.asList("*"));

        // Allow credentials (cookies, authorization headers, etc.)
        config.setAllowCredentials(true);

        // How long the response from a preflight request can be cached (in seconds)
        config.setMaxAge(3600L);

        // Expose headers that the client can access
        config.setExposedHeaders(Arrays.asList(
                "Authorization",
                "Content-Type",
                "X-Requested-With",
                "Accept",
                "Origin",
                "Access-Control-Request-Method",
                "Access-Control-Request-Headers"
        ));

        UrlBasedCorsConfigurationSource source = new UrlBasedCorsConfigurationSource();

        // Apply CORS config to ALL endpoints
        source.registerCorsConfiguration("/**", config);

        return source;
    }
}
</file>

<file path="src/main/java/com/atharv/Event_Ticket_Platform/Config/JwtAuthenticationConverter.java">
package com.atharv.Event_Ticket_Platform.Config;

import org.springframework.core.convert.converter.Converter;
import org.springframework.security.core.GrantedAuthority;
import org.springframework.security.core.authority.SimpleGrantedAuthority;
import org.springframework.security.oauth2.jwt.Jwt;
import org.springframework.security.oauth2.server.resource.authentication.JwtAuthenticationToken;
import org.springframework.stereotype.Component;

import java.util.Collection;
import java.util.Collections;
import java.util.List;
import java.util.Map;
import java.util.stream.Collectors;


@Component
public class JwtAuthenticationConverter implements Converter<Jwt, JwtAuthenticationToken> {

    @Override
    public JwtAuthenticationToken convert(Jwt jwt) {
        Collection<GrantedAuthority> roles=extractAuthorities(jwt);
        return new JwtAuthenticationToken(jwt,roles);
    }

    private Collection<GrantedAuthority> extractAuthorities(Jwt jwt){
        Map<String,Object> realmAccess=jwt.getClaim("realm_access");

        if(realmAccess==null || !realmAccess.containsKey("roles"))
            return Collections.emptyList();

        @SuppressWarnings("unchecked")
        List<String> roles=(List<String>) realmAccess.get("roles");

        Collection<GrantedAuthority> authorities=roles.stream().filter(role->role.startsWith("ROLE_")).map(role->new SimpleGrantedAuthority(role)).collect(Collectors.toList());

        return authorities;
    }
}
</file>

<file path="src/main/java/com/atharv/Event_Ticket_Platform/Config/KeycloakAdminConfig.java">
package com.atharv.Event_Ticket_Platform.Config;

import org.keycloak.admin.client.Keycloak;
import org.keycloak.admin.client.KeycloakBuilder;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;

@Configuration
public class KeycloakAdminConfig {

    @Value("${keycloak.admin.server-url}")
    private String serverUrl;

    @Value("${keycloak.admin.realm}")
    private String realm;

    @Value("${keycloak.admin.username}")
    private String username;

    @Value("${keycloak.admin.password}")
    private String password;

    @Value("${keycloak.admin.client-id}")
    private String clientId;

    /**
     * Creates a Keycloak admin client for managing users and roles
     */
    @Bean
    public Keycloak keycloak() {
        return KeycloakBuilder.builder()
                .serverUrl(serverUrl)
                .realm("master") // Login to master realm as admin
                .username(username)
                .password(password)
                .clientId(clientId)
                .build();
    }
}
</file>

<file path="src/main/java/com/atharv/Event_Ticket_Platform/Config/SecurityConfig.java">
package com.atharv.Event_Ticket_Platform.Config;

import com.atharv.Event_Ticket_Platform.Filters.StaffValidationFilter;
import com.atharv.Event_Ticket_Platform.Filters.UserProvisioningFilter;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.security.config.Customizer;
import org.springframework.security.config.annotation.web.builders.HttpSecurity;
import org.springframework.security.config.annotation.web.configuration.EnableWebSecurity;
import org.springframework.security.config.http.SessionCreationPolicy;
import org.springframework.security.oauth2.server.resource.web.authentication.BearerTokenAuthenticationFilter;
import org.springframework.security.web.SecurityFilterChain;


@Configuration
@EnableWebSecurity
public class SecurityConfig {

    @Bean
    public SecurityFilterChain securityFilterChain(
            HttpSecurity http,
            UserProvisioningFilter userProvisioningFilter,
            StaffValidationFilter staffValidationFilter,
            JwtAuthenticationConverter jwtAuthenticationConverter
    ) throws Exception {
        http
                .cors(Customizer.withDefaults())
                .csrf(csrf -> csrf.disable())
                .sessionManagement(session -> session.sessionCreationPolicy(SessionCreationPolicy.STATELESS))
                .authorizeHttpRequests(authorize -> authorize
                        // ==================== PUBLIC ENDPOINTS ====================
                        .requestMatchers("GET", "/api/v1/published-events/**").permitAll()

                        // ==================== ROLE MANAGEMENT ====================
                        .requestMatchers("POST", "/api/v1/roles/promote-to-organiser").authenticated()
                        .requestMatchers("GET", "/api/v1/roles/my-roles").authenticated()

                        // ==================== ORGANISER ENDPOINTS ====================
                        .requestMatchers("/api/v1/events/**").hasRole("ORGANISER")
                        .requestMatchers("/api/v1/staff/events/**").hasRole("ORGANISER")
                        .requestMatchers("/api/v1/organiser/events/**").hasRole("ORGANISER")

                        // ==================== STAFF ENDPOINTS ====================
                        // ‚úÖ CRITICAL: Staff can ONLY access validation endpoints
                        // They should NOT be able to access organizer or attendee endpoints
                        .requestMatchers("/api/v1/staff/validation/**").hasRole("STAFF")

                        // ==================== ATTENDEE ENDPOINTS ====================
                        .requestMatchers("/api/v1/tickets/**").authenticated()

                        // ==================== ALL OTHER REQUESTS ====================
                        .anyRequest().authenticated()
                )
                .oauth2ResourceServer(oauth2 -> oauth2.jwt(jwt -> jwt.jwtAuthenticationConverter(jwtAuthenticationConverter)))
                .addFilterAfter(userProvisioningFilter, BearerTokenAuthenticationFilter.class)
                .addFilterAfter(staffValidationFilter, UserProvisioningFilter.class);

        return http.build();
    }
}


    // above all the methods(csrf,sessionManagement,authorizeHttpRequest) takes consumer functional interface as argument , so we pass the lambda function which implements those consumer interfaces

    // if lambda's were not used then , this would be passed as

    /*
        public class DisableCsrfConsumer
        implements Consumer<CsrfConfigurer<HttpSecurity>> {
        @Override
        public void accept(CsrfConfigurer<HttpSecurity> csrf) {
            csrf.disable();
        }
}
         http.csrf(new DisableCsrfConsumer()); // here object of implementation of functional(consumer) interface is passed

         then came anonymous class , which directly passes the implementation  like without implementing the class , overriding the object with method

         http.csrf(new Consumer<CsrfConfigurer<HttpSecurity>>() {
            @Override
            public void accept(CsrfConfigurer<HttpSecurity> csrf) {
                csrf.disable();
            }
        });
        then came lambda's which directly passes the implementation , without implementing the class
     */


// in session-based authentication , server stores the user info at server side for authentication and authorization in session , but in jwt authentication data travels with every request so no need of storing the user info at server side so no session needed

// it is jwt based authentication , not session based  authentication so csrf is disabled because in session based authentication , session id is sent automatically with every request as it is browsers's tendency to attach the session cookies(info about user) with every request , so to prevent the cross - site request forgery , csrf is enabled , but in jwt based authentication jwt token is not send automatically with every request by browser as browser cannot attach the jwt in authorization header automatically

// oauth2ResourceServer(oauth2 ->oauth2.jwt(Customizer.withDefaults())) declares that the Spring Boot application is an OAuth 2.0 Resource Server, whose responsibility is to validate incoming JWT access tokens. and keycloak is authorization server that issues the jwt token to resource server and resource server validates the jwt

// BearerTokenAuthenticationFilter.class) built in spring filter that reads the jwt token from authorization header and validates it  and stores authentication obj in securityContextHolder
// addFilterAfter(A,B) means that Filter A should come after filter b
</file>

<file path="src/main/java/com/atharv/Event_Ticket_Platform/Controllers/AnalyticsController.java">
package com.atharv.Event_Ticket_Platform.Controllers;

import com.atharv.Event_Ticket_Platform.Service.ServiceImpl.AnalyticsService;
import com.atharv.Event_Ticket_Platform.util.UserFromJwt;
import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;
import org.springframework.http.ResponseEntity;
import org.springframework.security.access.prepost.PreAuthorize;
import org.springframework.security.core.annotation.AuthenticationPrincipal;
import org.springframework.security.oauth2.jwt.Jwt;
import org.springframework.web.bind.annotation.*;

import java.util.List;
import java.util.Map;
import java.util.UUID;

/**
 * üìä Analytics Controller
 * Provides comprehensive analytics endpoints for organizers
 */
@RestController
@RequestMapping("/api/v1/analytics")
@RequiredArgsConstructor
@Slf4j
@PreAuthorize("hasRole('ORGANISER')")
public class AnalyticsController {
    private final AnalyticsService analyticsService;

    /**
     * ‚úÖ Get complete analytics across ALL events
     * GET /api/v1/analytics/complete
     * <p>
     * Returns:
     * {
     * "organiserId": "uuid",
     * "organiserName": "John Smith",
     * "totalEvents": 5,
     * "publishedEvents": 3,
     * "draftEvents": 2,
     * "totalTicketsSold": 1500,
     * "totalRevenue": 75000.00,
     * "totalAttendeesValidated": 1200,
     * "averageAttendanceRate": 80.0,
     * "eventAnalytics": [
     * {
     * "eventId": "uuid",
     * "eventName": "Summer Festival",
     * "totalTicketsSold": 500,
     * "totalRevenue": 25000.00,
     * "totalAttendeesValidated": 400,
     * "overallAttendanceRate": 80.0,
     * "ticketTypeAnalytics": [
     * {
     * "ticketTypeId": 1,
     * "ticketTypeName": "VIP",
     * "price": 100.00,
     * "ticketsSold": 100,
     * "revenue": 10000.00,
     * "attendeesValidated": 95,
     * "attendanceRate": 95.0,
     * "remainingTickets": 0
     * },
     * {
     * "ticketTypeId": 2,
     * "ticketTypeName": "General",
     * "price": 50.00,
     * "ticketsSold": 400,
     * "revenue": 15000.00,
     * "attendeesValidated": 305,
     * "attendanceRate": 76.25,
     * "remainingTickets": 100
     * }
     * ]
     * }
     * ],
     * "mostRevenueEvent": {...},
     * "mostTicketsSoldEvent": {...},
     * "bestAttendanceRateEvent": {...}
     * }
     */
    @GetMapping("/complete")
    public ResponseEntity<?> getCompleteAnalytics(@AuthenticationPrincipal Jwt jwt) {
        UUID organiserId = UserFromJwt.parseUserId(jwt);
        log.info("Organiser {} requesting complete analytics", organiserId);

        try {
            var analytics = analyticsService.getCompleteOrganiserAnalytics(organiserId);
            return ResponseEntity.ok(analytics);
        } catch (IllegalStateException e) {
            return ResponseEntity.badRequest().body(Map.of(
                    "error", "Failed to get analytics",
                    "message", e.getMessage()
            ));
        } catch (Exception e) {
            log.error("Error getting complete analytics: {}", e.getMessage(), e);
            return ResponseEntity.internalServerError().body(Map.of(
                    "error", "Internal server error",
                    "message", "Failed to fetch analytics"
            ));
        }
    }

    /**
     * ‚úÖ Get analytics for only published events
     * GET /api/v1/analytics/published
     * <p>
     * Same structure as /complete but only for published events
     */
    @GetMapping("/published")
    public ResponseEntity<?> getPublishedEventsAnalytics(@AuthenticationPrincipal Jwt jwt) {
        UUID organiserId = UserFromJwt.parseUserId(jwt);
        log.info("Organiser {} requesting published events analytics", organiserId);

        try {
            var analytics = analyticsService.getPublishedEventsAnalytics(organiserId);
            return ResponseEntity.ok(analytics);
        } catch (Exception e) {
            log.error("Error getting published events analytics: {}", e.getMessage(), e);
            return ResponseEntity.internalServerError().build();
        }
    }

    /**
     * ‚úÖ Get analytics for a specific event
     * GET /api/v1/analytics/events/{eventId}
     * <p>
     * Returns detailed analytics for one event including:
     * - Total tickets sold
     * - Total revenue
     * - Total attendees validated
     * - Breakdown per ticket type
     * <p>
     * Response:
     * {
     * "eventId": "uuid",
     * "eventName": "Summer Festival",
     * "eventStatus": "PUBLISHED",
     * "totalTicketsSold": 500,
     * "totalRevenue": 25000.00,
     * "totalAttendeesValidated": 400,
     * "overallAttendanceRate": 80.0,
     * "ticketTypeAnalytics": [...]
     * }
     */
    @GetMapping("/events/{eventId}")
    public ResponseEntity<?> getEventAnalytics(
            @AuthenticationPrincipal Jwt jwt,
            @PathVariable UUID eventId
    ) {
        UUID organiserId = UserFromJwt.parseUserId(jwt);
        log.info("Organiser {} requesting analytics for event {}", organiserId, eventId);

        try {
            var analytics = analyticsService.getEventAnalytics(eventId, organiserId);
            return ResponseEntity.ok(analytics);
        } catch (IllegalStateException e) {
            return ResponseEntity.badRequest().body(Map.of(
                    "error", "Failed to get event analytics",
                    "message", e.getMessage()
            ));
        } catch (Exception e) {
            log.error("Error getting event analytics: {}", e.getMessage(), e);
            return ResponseEntity.internalServerError().build();
        }
    }

    /**
     * üÜï Get ticket type performance across ALL events
     * GET /api/v1/analytics/ticket-types/performance
     * <p>
     * Shows which ticket type names perform best overall
     * <p>
     * Response:
     * [
     * {
     * "ticketTypeName": "VIP",
     * "totalSold": 500,
     * "totalRevenue": 50000.00,
     * "totalValidated": 475,
     * "averagePrice": 100.00,
     * "numberOfEvents": 3
     * },
     * {
     * "ticketTypeName": "General Admission",
     * "totalSold": 1000,
     * "totalRevenue": 25000.00,
     * "totalValidated": 800,
     * "averagePrice": 25.00,
     * "numberOfEvents": 5
     * }
     * ]
     */
    @GetMapping("/ticket-types/performance")
    public ResponseEntity<?> getTicketTypePerformance(@AuthenticationPrincipal Jwt jwt) {
        UUID organiserId = UserFromJwt.parseUserId(jwt);
        log.info("Organiser {} requesting ticket type performance", organiserId);

        try {
            var performance = analyticsService.getTicketTypePerformanceAcrossEvents(organiserId);
            return ResponseEntity.ok(performance);
        } catch (Exception e) {
            log.error("Error getting ticket type performance: {}", e.getMessage(), e);
            return ResponseEntity.internalServerError().build();
        }
    }

    /**
     * üÜï Compare multiple events side-by-side
     * POST /api/v1/analytics/events/compare
     * <p>
     * Request Body:
     * {
     * "eventIds": ["uuid1", "uuid2", "uuid3"]
     * }
     * <p>
     * Response:
     * {
     * "events": [
     * {
     * "eventId": "uuid1",
     * "eventName": "Event 1",
     * "totalTicketsSold": 500,
     * "totalRevenue": 25000.00,
     * ...
     * },
     * ...
     * ],
     * "comparisonCount": 3,
     * "organiserId": "uuid"
     * }
     */
    @PostMapping("/events/compare")
    public ResponseEntity<?> compareEvents(
            @AuthenticationPrincipal Jwt jwt,
            @RequestBody Map<String, List<String>> request
    ) {
        UUID organiserId = UserFromJwt.parseUserId(jwt);

        List<String> eventIdStrings = request.get("eventIds");
        if (eventIdStrings == null || eventIdStrings.isEmpty()) {
            return ResponseEntity.badRequest().body(Map.of(
                    "error", "Invalid request",
                    "message", "eventIds array is required"
            ));
        }

        try {
            List<UUID> eventIds = eventIdStrings.stream()
                    .map(UUID::fromString)
                    .toList();

            log.info("Organiser {} comparing {} events", organiserId, eventIds.size());

            var comparison = analyticsService.compareEvents(organiserId, eventIds);
            return ResponseEntity.ok(comparison);
        } catch (IllegalArgumentException e) {
            return ResponseEntity.badRequest().body(Map.of(
                    "error", "Invalid event ID format",
                    "message", e.getMessage()
            ));
        } catch (Exception e) {
            log.error("Error comparing events: {}", e.getMessage(), e);
            return ResponseEntity.internalServerError().build();
        }
    }

    /**
     * üÜï Get summary statistics (lightweight endpoint)
     * GET /api/v1/analytics/summary
     * <p>
     * Quick overview without full event breakdown
     * <p>
     * Response:
     * {
     * "totalEvents": 5,
     * "totalTicketsSold": 1500,
     * "totalRevenue": 75000.00,
     * "totalAttendeesValidated": 1200,
     * "averageAttendanceRate": 80.0
     * }
     */
    @GetMapping("/summary")
    public ResponseEntity<?> getAnalyticsSummary(@AuthenticationPrincipal Jwt jwt) {
        UUID organiserId = UserFromJwt.parseUserId(jwt);
        log.info("Organiser {} requesting analytics summary", organiserId);

        try {
            var fullAnalytics = analyticsService.getCompleteOrganiserAnalytics(organiserId);

            Map<String, Object> summary = Map.of(
                    "organiserId", fullAnalytics.getOrganiserId(),
                    "organiserName", fullAnalytics.getOrganiserName(),
                    "totalEvents", fullAnalytics.getTotalEvents(),
                    "publishedEvents", fullAnalytics.getPublishedEvents(),
                    "draftEvents", fullAnalytics.getDraftEvents(),
                    "totalTicketsSold", fullAnalytics.getTotalTicketsSold(),
                    "totalRevenue", fullAnalytics.getTotalRevenue(),
                    "totalAttendeesValidated", fullAnalytics.getTotalAttendeesValidated(),
                    "averageAttendanceRate", fullAnalytics.getAverageAttendanceRate()
            );

            return ResponseEntity.ok(summary);
        } catch (Exception e) {
            log.error("Error getting analytics summary: {}", e.getMessage(), e);
            return ResponseEntity.internalServerError().build();
        }
    }
}
</file>

<file path="src/main/java/com/atharv/Event_Ticket_Platform/Controllers/EventController.java">
package com.atharv.Event_Ticket_Platform.Controllers;

import com.atharv.Event_Ticket_Platform.Domain.DTO.EventDtos.*;
import com.atharv.Event_Ticket_Platform.Domain.Entity.Event;
import com.atharv.Event_Ticket_Platform.Domain.Mapper.EventMapper;
import com.atharv.Event_Ticket_Platform.Domain.Requests.CreateEventRequest;
import com.atharv.Event_Ticket_Platform.Service.ServiceInterface.EventService;
import jakarta.validation.Valid;
import lombok.RequiredArgsConstructor;
import org.springframework.data.domain.Page;
import org.springframework.data.domain.Pageable;
import org.springframework.http.HttpStatus;
import org.springframework.http.ResponseEntity;
import org.springframework.security.core.annotation.AuthenticationPrincipal;
import org.springframework.security.oauth2.jwt.Jwt;
import org.springframework.web.bind.annotation.*;

import java.util.UUID;

import static com.atharv.Event_Ticket_Platform.util.UserFromJwt.parseUserId;

@RestController
@RequestMapping(path ="/api/v1/events")
@CrossOrigin(origins = "*", maxAge = 3600)
@RequiredArgsConstructor
public class EventController {

    private final EventService eventService;
    private final EventMapper eventMapper;
    //@AuthenticationPrincipal is used to access authenticated user from Security Context

    @PostMapping("createEvent")
    public ResponseEntity<EventCreatedResponseDto> createEvent(@AuthenticationPrincipal Jwt jwt, @Valid @RequestBody CreateEventRequestDto createEventRequestDto){
        System.out.println("CONTROLLER HIT");
        CreateEventRequest createEventRequest=eventMapper.fromDto(createEventRequestDto);
        UUID userId = UUID.fromString(jwt.getSubject());
        Event event = eventService.createEvent(userId,createEventRequest,jwt);
        EventCreatedResponseDto eventCreatedResponseDto= eventMapper.toDto(event);
        return new ResponseEntity<>(eventCreatedResponseDto, HttpStatus.CREATED);
    }

    @GetMapping("listEvent")
    public ResponseEntity<Page<ListEventResponseDto>> listEvent(@AuthenticationPrincipal Jwt jwt,Pageable pageable){
        UUID organiserId = parseUserId(jwt);
        Page<Event> evnt=eventService.listEventForOrganiser(organiserId,pageable);
         Page<ListEventResponseDto> listEventResponseDtos=evnt.map(eventMapper::toListEventResponseDto);
        return new ResponseEntity<>(listEventResponseDtos,HttpStatus.OK);
    }


    @GetMapping("getEvent/{eventId}")
    public ResponseEntity<EventResponseDto> getEvent(
            @AuthenticationPrincipal Jwt jwt, @PathVariable UUID eventId
    ){
        UUID organiserId=parseUserId(jwt);
        Event event = eventService.getEvent(eventId,organiserId);
        return new ResponseEntity<>(eventMapper.toEventResponseDto(event),HttpStatus.OK);
    }


    @PatchMapping("updateEvent/{eventId}")
    public ResponseEntity<UpdatedEventResponseDto> getEvent(@AuthenticationPrincipal Jwt jwt , @PathVariable UUID eventId, @RequestBody UpdateEventRequestDto updateEventRequestDto){
        UUID userId=parseUserId(jwt);
        Event updatedEvent =eventService.updateEvent(userId,eventId,updateEventRequestDto);
        UpdatedEventResponseDto updatedEventResponseDto=eventMapper.toUpdatedEventResponseDto(updatedEvent);
        return new ResponseEntity<>(updatedEventResponseDto,HttpStatus.OK);
    }

    @DeleteMapping("{eventID}")
    public ResponseEntity<Void> DeleteEvent(@AuthenticationPrincipal Jwt jwt , @PathVariable UUID eventID){
        UUID organiser=parseUserId(jwt);
            eventService.deleteEvent(eventID,organiser);
        return ResponseEntity.noContent().build();
    }

    @DeleteMapping("{eventId}/ticket-types/{ticketTypeId}")
    public ResponseEntity<Void> deleteTicketType(
            @AuthenticationPrincipal Jwt jwt,
            @PathVariable UUID eventId,
            @PathVariable Integer ticketTypeId
    ) {
        UUID organiserId = parseUserId(jwt);
        eventService.deleteTicketType(organiserId, eventId, ticketTypeId);
        return ResponseEntity.noContent().build();
    }



}
</file>

<file path="src/main/java/com/atharv/Event_Ticket_Platform/Controllers/GlobalExceptionHandler.java">
package com.atharv.Event_Ticket_Platform.Controllers;

import com.atharv.Event_Ticket_Platform.Domain.DTO.ErrorDtos.ErrorDto;
import com.atharv.Event_Ticket_Platform.Exceptions.*;
import jakarta.validation.ConstraintViolationException;
import lombok.extern.slf4j.Slf4j;
import org.springframework.http.HttpStatus;
import org.springframework.http.ResponseEntity;
import org.springframework.validation.FieldError;
import org.springframework.web.bind.MethodArgumentNotValidException;
import org.springframework.web.bind.annotation.ExceptionHandler;
import org.springframework.web.bind.annotation.RestControllerAdvice;

import java.util.List;
import java.util.Map;

@Slf4j
@RestControllerAdvice
public class GlobalExceptionHandler {


    @ExceptionHandler(UserNotFoundExceptions.class)
    public ResponseEntity<ErrorDto> handleExceptions(UserNotFoundExceptions ex){
        log.error("user not found....",ex);
        ErrorDto errorDto = new ErrorDto();
        errorDto.setError("user not found");
        return  new ResponseEntity<>(errorDto,HttpStatus.NOT_FOUND);
    }

    @ExceptionHandler(ConstraintViolationException.class)
    public ResponseEntity<ErrorDto> handleExceptions(ConstraintViolationException ex){
        log.error("unexpected error occured...",ex);
        ErrorDto errorDto = new ErrorDto();
        String msg=ex.getConstraintViolations().stream().findFirst().map(constraintViolation -> constraintViolation.getPropertyPath()+":"+constraintViolation.getMessage()).orElse("Constrain Violation error occured");
        errorDto.setError(msg);
        return new ResponseEntity<>(errorDto,HttpStatus.BAD_REQUEST);
    }

    @ExceptionHandler(MethodArgumentNotValidException.class)
    public ResponseEntity<ErrorDto> handleExceptions(MethodArgumentNotValidException ex){
        ErrorDto errorDto = new ErrorDto();
        List<FieldError> fieldErrors= ex.getBindingResult().getFieldErrors();
        String message = fieldErrors.stream().findFirst().map(fieldError -> fieldError.getField() +":"+fieldError.getDefaultMessage()).orElse("Validation Error Occured");
        errorDto.setError(message);
        return new ResponseEntity<>(errorDto,HttpStatus.BAD_REQUEST);
    }

    @ExceptionHandler(ResourceNotFoundException.class)
    public ResponseEntity<?> handleNotFound(ResourceNotFoundException ex) {
        return ResponseEntity.status(HttpStatus.NOT_FOUND)
                .body(Map.of("message", ex.getMessage()));
    }

    @ExceptionHandler(Exception.class)
    public ResponseEntity<ErrorDto> handleExceptions(Exception ex){
        log.error("unexpected error occured...",ex);
        ErrorDto errorDto = new ErrorDto("UnExpected error occured..");
        return new ResponseEntity<>(errorDto,HttpStatus.INTERNAL_SERVER_ERROR);
    }

    @ExceptionHandler(QrCodeNotGeneratedException.class)
    public ResponseEntity<ErrorDto> handleExceptions(QrCodeNotGeneratedException ex){
        log.error("QR not Generated....",ex);
        ErrorDto errorDto = new ErrorDto();
        errorDto.setError("QR not Generated not found");
        return  new ResponseEntity<>(errorDto,HttpStatus.INTERNAL_SERVER_ERROR);
    }


    @ExceptionHandler(QrCodeNotFoundException.class)
    public ResponseEntity<ErrorDto> handleExceptions(QrCodeNotFoundException ex){
        log.error("QR not found....",ex);
        ErrorDto errorDto = new ErrorDto();
        errorDto.setError("QR not found");
        return  new ResponseEntity<>(errorDto,HttpStatus.NOT_FOUND);
    }

    @ExceptionHandler(TicketSoldOutException.class)
    public ResponseEntity<ErrorDto> handleExceptions(TicketSoldOutException ex){
        log.error("All tickets of this Ticket Type sold out",ex);
        ErrorDto errorDto = new ErrorDto();
        errorDto.setError("All ticket of this Ticket Type Sold out");
        return  new ResponseEntity<>(errorDto,HttpStatus.BAD_REQUEST);
    }

}
</file>

<file path="src/main/java/com/atharv/Event_Ticket_Platform/Controllers/KeycloakRoleController.java">
package com.atharv.Event_Ticket_Platform.Controllers;

import com.atharv.Event_Ticket_Platform.Service.ServiceImpl.KeycloakRoleService;
import com.atharv.Event_Ticket_Platform.util.UserFromJwt;
import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;
import org.springframework.http.ResponseEntity;
import org.springframework.security.core.annotation.AuthenticationPrincipal;
import org.springframework.security.oauth2.jwt.Jwt;
import org.springframework.web.bind.annotation.*;

import java.util.List;
import java.util.Map;
import java.util.UUID;

@RestController
@RequestMapping("/api/v1/roles")
@RequiredArgsConstructor
@Slf4j
public class KeycloakRoleController {

    private final KeycloakRoleService keycloakRoleService;

    /**
     * Endpoint called when user clicks "List an Event" button
     * This promotes them to ROLE_ORGANISER in Keycloak
     */
    @PostMapping("/promote-to-organiser")
    public ResponseEntity<Map<String, Object>> promoteToOrganiser(@AuthenticationPrincipal Jwt jwt) {
        UUID userId = UserFromJwt.parseUserId(jwt);
        log.info("User {} requesting promotion to ROLE_ORGANISER", userId);

        try {
            keycloakRoleService.promoteToOrganiser(userId.toString());

            List<String> updatedRoles = keycloakRoleService.getUserRoles(userId.toString());

            return ResponseEntity.ok(Map.of(
                    "message", "Successfully promoted to organiser. Please log out and log back in for changes to take effect.",
                    "userId", userId,
                    "roles", updatedRoles,
                    "requiresRelogin", true  // Frontend should prompt user to re-login
            ));
        } catch (Exception e) {
            log.error("Failed to promote user {} to organiser: {}", userId, e.getMessage());
            return ResponseEntity.internalServerError().body(Map.of(
                    "error", "Failed to promote user",
                    "message", e.getMessage()
            ));
        }
    }

    /**
     * Get current user's roles from Keycloak
     */
    @GetMapping("/my-roles")
    public ResponseEntity<Map<String, Object>> getMyRoles(@AuthenticationPrincipal Jwt jwt) {
        UUID userId = UserFromJwt.parseUserId(jwt);

        try {
            List<String> roles = keycloakRoleService.getUserRoles(userId.toString());

            return ResponseEntity.ok(Map.of(
                    "userId", userId,
                    "roles", roles
            ));
        } catch (Exception e) {
            log.error("Failed to get roles for user {}: {}", userId, e.getMessage());
            return ResponseEntity.internalServerError().body(Map.of(
                    "error", "Failed to retrieve roles",
                    "message", e.getMessage()
            ));
        }
    }
}
</file>

<file path="src/main/java/com/atharv/Event_Ticket_Platform/Controllers/KeycloakStaffController.java">
package com.atharv.Event_Ticket_Platform.Controllers;

import com.atharv.Event_Ticket_Platform.Domain.DTO.StaffDtos.*;
import com.atharv.Event_Ticket_Platform.Domain.Entity.Staff;
import com.atharv.Event_Ticket_Platform.Repository.StaffRepo;
import com.atharv.Event_Ticket_Platform.Service.ServiceImpl.KeycloakUserService;
import com.atharv.Event_Ticket_Platform.util.UserFromJwt;
import lombok.Builder;
import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;
import org.springframework.data.domain.Page;
import org.springframework.data.domain.Pageable;
import org.springframework.http.ResponseEntity;
import org.springframework.security.access.prepost.PreAuthorize;
import org.springframework.security.core.annotation.AuthenticationPrincipal;
import org.springframework.security.oauth2.jwt.Jwt;
import org.springframework.web.bind.annotation.*;

import java.time.LocalDateTime;
import java.util.List;
import java.util.Map;
import java.util.UUID;

@RestController
@RequestMapping("/api/v1/staff")
@RequiredArgsConstructor
@Slf4j @Builder
public class KeycloakStaffController {

    private final KeycloakUserService keycloakUserService;
    private final StaffRepo staffRepo;

    /**
     * ‚úÖ Generate staff accounts for a specific event
     * POST /api/v1/staff/events/{eventId}/generate
     */
    @PostMapping("/events/{eventId}/generate")
    @PreAuthorize("hasRole('ORGANISER')")
    public ResponseEntity<GenerateStaffResponseDto> generateStaffAccounts(
            @AuthenticationPrincipal Jwt jwt,
            @PathVariable UUID eventId,
            @RequestBody GenerateStaffRequestDto request
    ) {
        UUID organiserId = UserFromJwt.parseUserId(jwt);
        log.info("Organiser {} requesting {} staff accounts for event {} with {} hours validity",
                organiserId, request.getCount(), eventId, request.getValidityHours());

        // Defaults
        int count = request.getCount() != null ? request.getCount() : 1;
        int validityHours = request.getValidityHours() != null ? request.getValidityHours() : 24;

        try {
            List<StaffCredentialWithPasswordDto> credentials =
                    keycloakUserService.createStaffAccounts(organiserId, eventId, count, validityHours);

            LocalDateTime validFrom = LocalDateTime.now();
            LocalDateTime validUntil = validFrom.plusHours(validityHours);

            GenerateStaffResponseDto response = GenerateStaffResponseDto.builder()
                    .message("Staff accounts created successfully")
                    .organiserId(organiserId)
                    .eventId(eventId)
                    .staffCount(credentials.size())
                    .validityHours(validityHours)
                    .validFrom(validFrom)
                    .validUntil(validUntil)
                    .credentials(credentials)
                    .build();

            return ResponseEntity.ok(response);
        } catch (Exception e) {
            log.error("Failed to create staff accounts: {}", e.getMessage(), e);
            return ResponseEntity.internalServerError().build();
        }
    }

    /**
     * ‚úÖ Get all staff for a specific event (including expired ones)
     * GET /api/v1/staff/events/{eventId}
     */
    @GetMapping("/events/{eventId}")
    @PreAuthorize("hasRole('ORGANISER')")
    public ResponseEntity<Page<StaffCredentialsDto>> getStaffByEvent(
            @AuthenticationPrincipal Jwt jwt,
            @PathVariable UUID eventId,
            Pageable pageable
    ) {
        UUID organiserId = UserFromJwt.parseUserId(jwt);
        log.info("Organiser {} fetching staff for event {}", organiserId, eventId);

        try {
            Page<Staff> staffPage = staffRepo.findByCreatedByOrganiserIdAndEventId(
                    organiserId, eventId, pageable
            );

            Page<StaffCredentialsDto> dtos = staffPage.map(staff ->
                    StaffCredentialsDto.builder()
                            .id(staff.getId())
                            .staffUserId(staff.getStaffUserId())
                            .username(staff.getUsername())
                            .email(staff.getEmail())
                            .isActive(staff.getIsActive())
                            .validFrom(staff.getValidFrom())
                            .validUntil(staff.getValidUntil())
                            .isExpired(staff.isExpired())
                            .createdAt(staff.getCreatedAt())
                            .lastLogin(staff.getLastLogin())
                            .build()
            );

            return ResponseEntity.ok(dtos);

        } catch (Exception e) {
            log.error("Failed to fetch staff: {}", e.getMessage(), e);
            return ResponseEntity.internalServerError().build();
        }
    }

    /**
     * ‚úÖ Get only active (non-expired) staff for a specific event
     * GET /api/v1/staff/events/{eventId}/active
     */
    @GetMapping("/events/{eventId}/active")
    @PreAuthorize("hasRole('ORGANISER')")
    public ResponseEntity<Page<StaffCredentialsDto>> getActiveStaffByEvent(
            @AuthenticationPrincipal Jwt jwt,
            @PathVariable UUID eventId,
            Pageable pageable
    ) {
        UUID organiserId = UserFromJwt.parseUserId(jwt);
        log.info("Organiser {} fetching active staff for event {}", organiserId, eventId);

        try {
            Page<Staff> staffPage = staffRepo.findValidStaffByEvent(
                    organiserId, eventId, LocalDateTime.now(), pageable
            );

            Page<StaffCredentialsDto> dtos = staffPage.map(staff ->
                    StaffCredentialsDto.builder()
                            .id(staff.getId())
                            .staffUserId(staff.getStaffUserId())
                            .username(staff.getUsername())
                            .email(staff.getEmail())
                            .isActive(staff.getIsActive())
                            .validFrom(staff.getValidFrom())
                            .validUntil(staff.getValidUntil())
                            .isExpired(false) // These are all active
                            .createdAt(staff.getCreatedAt())
                            .lastLogin(staff.getLastLogin())
                            .build()
            );

            return ResponseEntity.ok(dtos);

        } catch (Exception e) {
            log.error("Failed to fetch active staff: {}", e.getMessage(), e);
            return ResponseEntity.internalServerError().build();
        }
    }

    /**
     * ‚úÖ Delete a staff user from a specific event
     * DELETE /api/v1/staff/events/{eventId}/users/{userId}
     */
    @DeleteMapping("/events/{eventId}/users/{userId}")
    @PreAuthorize("hasRole('ORGANISER')")
    public ResponseEntity<Map<String, String>> deleteStaffUser(
            @AuthenticationPrincipal Jwt jwt,
            @PathVariable UUID eventId,
            @PathVariable String userId
    ) {
        UUID organiserId = UserFromJwt.parseUserId(jwt);
        log.info("Organiser {} deleting staff user {} from event {}",
                organiserId, userId, eventId);

        try {
            keycloakUserService.deleteStaffUser(organiserId, eventId, userId);

            return ResponseEntity.ok(Map.of(
                    "message", "Staff user deleted successfully",
                    "userId", userId,
                    "eventId", eventId.toString()
            ));
        } catch (Exception e) {
            log.error("Failed to delete staff user: {}", e.getMessage());
            return ResponseEntity.internalServerError().body(Map.of(
                    "error", "Failed to delete staff user",
                    "message", e.getMessage()
            ));
        }
    }

    /**
     * ‚úÖ Reset staff user password
     * POST /api/v1/staff/events/{eventId}/users/{userId}/reset-password
     */
    @PostMapping("/events/{eventId}/users/{userId}/reset-password")
    @PreAuthorize("hasRole('ORGANISER')")
    public ResponseEntity<Map<String, String>> resetStaffPassword(
            @AuthenticationPrincipal Jwt jwt,
            @PathVariable UUID eventId,
            @PathVariable String userId
    ) {
        UUID organiserId = UserFromJwt.parseUserId(jwt);
        log.info("Organiser {} resetting password for staff user {} in event {}",
                organiserId, userId, eventId);

        try {
            String newPassword = keycloakUserService.resetPassword(organiserId, eventId, userId);

            return ResponseEntity.ok(Map.of(
                    "message", "Password reset successfully",
                    "userId", userId,
                    "eventId", eventId.toString(),
                    "newPassword", newPassword,
                    "note", "‚ö†Ô∏è Save this password securely. It won't be shown again."
            ));
        } catch (Exception e) {
            log.error("Failed to reset password: {}", e.getMessage());
            return ResponseEntity.internalServerError().body(Map.of(
                    "error", "Failed to reset password",
                    "message", e.getMessage()
            ));
        }
    }

    /**
     * ‚úÖ Extend validity period for a staff member
     * POST /api/v1/staff/events/{eventId}/users/{userId}/extend-validity
     */
    @PostMapping("/events/{eventId}/users/{userId}/extend-validity")
    @PreAuthorize("hasRole('ORGANISER')")
    public ResponseEntity<Map<String, Object>> extendValidity(
            @AuthenticationPrincipal Jwt jwt,
            @PathVariable UUID eventId,
            @PathVariable String userId,
            @RequestParam int hours
    ) {
        UUID organiserId = UserFromJwt.parseUserId(jwt);
        log.info("Organiser {} extending validity for staff {} by {} hours",
                organiserId, userId, hours);

        try {
            Staff updatedStaff = keycloakUserService.extendValidity(
                    organiserId, eventId, userId, hours
            );

            return ResponseEntity.ok(Map.of(
                    "message", "Validity extended successfully",
                    "userId", userId,
                    "eventId", eventId.toString(),
                    "newValidUntil", updatedStaff.getValidUntil(),
                    "extendedBy", hours + " hours"
            ));
        } catch (Exception e) {
            log.error("Failed to extend validity: {}", e.getMessage());
            return ResponseEntity.internalServerError().body(Map.of(
                    "error", "Failed to extend validity",
                    "message", e.getMessage()
            ));
        }
    }

    /**
     * ‚úÖ Get staff statistics for an event
     * GET /api/v1/staff/events/{eventId}/stats
     */
    @GetMapping("/events/{eventId}/stats")
    @PreAuthorize("hasRole('ORGANISER')")
    public ResponseEntity<Map<String, Object>> getStaffStats(
            @AuthenticationPrincipal Jwt jwt,
            @PathVariable UUID eventId
    ) {
        UUID organiserId = UserFromJwt.parseUserId(jwt);

        try {
            List<Staff> allStaff = staffRepo.findByCreatedByOrganiserIdAndEventId(
                    organiserId, eventId
            );

            long total = allStaff.size();
            long active = allStaff.stream()
                    .filter(Staff::isValidNow)
                    .count();
            long expired = allStaff.stream()
                    .filter(Staff::isExpired)
                    .count();
            long inactive = allStaff.stream()
                    .filter(s -> !s.getIsActive())
                    .count();

            return ResponseEntity.ok(Map.of(
                    "eventId", eventId,
                    "total", total,
                    "active", active,
                    "expired", expired,
                    "inactive", inactive
            ));
        } catch (Exception e) {
            log.error("Failed to get stats: {}", e.getMessage());
            return ResponseEntity.internalServerError().build();
        }
    }
}
</file>

<file path="src/main/java/com/atharv/Event_Ticket_Platform/Controllers/OrganiserDashboardController.java">
package com.atharv.Event_Ticket_Platform.Controllers;

import com.atharv.Event_Ticket_Platform.Domain.DTO.AnalyticDtos.ValidatedAttendeeResponse;
import com.atharv.Event_Ticket_Platform.Service.ServiceImpl.AnalyticsService;
import com.atharv.Event_Ticket_Platform.Service.ServiceImpl.ValidationStatsService;
import com.atharv.Event_Ticket_Platform.util.UserFromJwt;
import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;
import org.springframework.data.domain.Page;
import org.springframework.data.domain.PageRequest;
import org.springframework.data.domain.Pageable;
import org.springframework.data.domain.Sort;
import org.springframework.http.ResponseEntity;
import org.springframework.security.access.prepost.PreAuthorize;
import org.springframework.security.core.annotation.AuthenticationPrincipal;
import org.springframework.security.oauth2.jwt.Jwt;
import org.springframework.web.bind.annotation.*;

import java.util.Map;
import java.util.UUID;

/**
 * üÜï Organiser Dashboard Controller with Revenue Tracking
 * Provides endpoints for organisers to view event validation statistics,
 * track staff performance, and monitor revenue
 */
@RestController
@RequestMapping("/api/v1/organiser/events/{eventId}/dashboard")
@RequiredArgsConstructor
@Slf4j
@PreAuthorize("hasRole('ORGANISER')")
public class OrganiserDashboardController {

    private final ValidationStatsService statsService;

    /**
     * ‚úÖ Get overall event validation and revenue statistics
     * GET /api/v1/organiser/events/{eventId}/dashboard/stats
     *
     * Response:
     * {
     *   "eventId": "uuid",
     *   "eventName": "Summer Music Festival",
     *   "totalTicketsSold": 500,
     *   "totalValidated": 342,
     *   "remainingAttendees": 158,
     *   "totalRevenue": 25000.00,
     *   "revenueByTicketType": [
     *     {
     *       "ticketTypeId": 1,
     *       "ticketTypeName": "VIP",
     *       "ticketsSold": 100,
     *       "revenue": 10000.00,
     *       "averagePrice": 100.00
     *     },
     *     {
     *       "ticketTypeId": 2,
     *       "ticketTypeName": "General Admission",
     *       "ticketsSold": 400,
     *       "revenue": 15000.00,
     *       "averagePrice": 37.50
     *     }
     *   ]
     * }
     */
    @GetMapping("/stats")
    public ResponseEntity<?> getEventDashboardStats(
            @AuthenticationPrincipal Jwt jwt,
            @PathVariable UUID eventId
    ) {
        UUID organiserId = UserFromJwt.parseUserId(jwt);
        log.info("Organiser {} requesting dashboard stats for event {}", organiserId, eventId);

        try {
            var stats = statsService.getEventDashboardStats(eventId);
            return ResponseEntity.ok(stats);
        } catch (IllegalStateException e) {
            return ResponseEntity.badRequest().body(Map.of(
                    "error", "Failed to get stats",
                    "message", e.getMessage()
            ));
        } catch (Exception e) {
            log.error("Error getting dashboard stats: {}", e.getMessage(), e);
            return ResponseEntity.internalServerError().build();
        }
    }

    /**
     * Get validation count per ticket type
     * GET /api/v1/organiser/events/{eventId}/dashboard/ticket-types
     *
     * Response:
     * [
     *   {
     *     "ticketTypeId": 1,
     *     "ticketTypeName": "VIP",
     *     "validatedCount": 45
     *   },
     *   {
     *     "ticketTypeId": 2,
     *     "ticketTypeName": "General Admission",
     *     "validatedCount": 297
     *   }
     * ]
     */
    @GetMapping("/ticket-types")
    public ResponseEntity<?> getValidationsByTicketType(
            @AuthenticationPrincipal Jwt jwt,
            @PathVariable UUID eventId
    ) {
        UUID organiserId = UserFromJwt.parseUserId(jwt);
        log.info("Organiser {} requesting ticket type stats for event {}", organiserId, eventId);

        try {
            var stats = statsService.getValidatedAttendeesPerTicketType(eventId, organiserId);
            return ResponseEntity.ok(stats);
        } catch (IllegalStateException e) {
            return ResponseEntity.badRequest().body(Map.of(
                    "error", "Failed to get ticket type stats",
                    "message", e.getMessage()
            ));
        } catch (Exception e) {
            log.error("Error getting ticket type stats: {}", e.getMessage(), e);
            return ResponseEntity.internalServerError().build();
        }
    }

    /**
     * Get validation count per staff member
     * GET /api/v1/organiser/events/{eventId}/dashboard/staff
     *
     * Response:
     * [
     *   {
     *     "staffUserId": "uuid",
     *     "staffUsername": "staff_abc123",
     *     "validatedCount": 78
     *   },
     *   {
     *     "staffUserId": "uuid",
     *     "staffUsername": "staff_xyz789",
     *     "validatedCount": 65
     *   }
     * ]
     */
    @GetMapping("/staff")
    public ResponseEntity<?> getValidationsByStaff(
            @AuthenticationPrincipal Jwt jwt,
            @PathVariable UUID eventId
    ) {
        UUID organiserId = UserFromJwt.parseUserId(jwt);
        log.info("Organiser {} requesting staff stats for event {}", organiserId, eventId);

        try {
            var stats = statsService.getAllStaffStatsForEvent(eventId, organiserId);
            return ResponseEntity.ok(stats);
        } catch (IllegalStateException e) {
            return ResponseEntity.badRequest().body(Map.of(
                    "error", "Failed to get staff stats",
                    "message", e.getMessage()
            ));
        } catch (Exception e) {
            log.error("Error getting staff stats: {}", e.getMessage(), e);
            return ResponseEntity.internalServerError().build();
        }
    }

    /**
     * Get detailed list of attendees validated by a specific staff member
     * GET /api/v1/organiser/events/{eventId}/dashboard/staff/{staffUserId}/validations
     *
     * Response (paginated):
     * {
     *   "content": [
     *     {
     *       "validationId": "uuid",
     *       "ticketId": "uuid",
     *       "ticketTypeName": "VIP",
     *       "attendeeName": "John Doe",
     *       "attendeeEmail": "john@example.com",
     *       "validationMethod": "QR",
     *       "validationStatus": "VALID",
     *       "validatedAt": "2026-01-20T14:30:00"
     *     }
     *   ],
     *   "totalElements": 78,
     *   "totalPages": 4
     * }
     */
    @GetMapping("/staff/{staffUserId}/validations")
    public ResponseEntity<?> getAttendeesValidatedByStaff(
            @AuthenticationPrincipal Jwt jwt,
            @PathVariable UUID eventId,
            @PathVariable UUID staffUserId,
            Pageable pageable
    ) {
        UUID organiserId = UserFromJwt.parseUserId(jwt);
        log.info("Organiser {} requesting validation details for staff {} in event {}",
                organiserId, staffUserId, eventId);

        try {
            var validations = statsService.getAttendeesValidatedByStaff(
                    eventId, staffUserId, organiserId, pageable
            );
            return ResponseEntity.ok(validations);
        } catch (IllegalStateException e) {
            return ResponseEntity.badRequest().body(Map.of(
                    "error", "Failed to get validation details",
                    "message", e.getMessage()
            ));
        } catch (Exception e) {
            log.error("Error getting validation details: {}", e.getMessage(), e);
            return ResponseEntity.internalServerError().build();
        }
    }

    /**
     * üÜï Get revenue summary for the event
     * GET /api/v1/organiser/events/{eventId}/dashboard/revenue
     *
     * This is an alias/shortcut to get just the revenue data
     */
    @GetMapping("/revenue")
    public ResponseEntity<?> getRevenueStats(
            @AuthenticationPrincipal Jwt jwt,
            @PathVariable UUID eventId
    ) {
        UUID organiserId = UserFromJwt.parseUserId(jwt);
        log.info("Organiser {} requesting revenue stats for event {}", organiserId, eventId);

        try {
            var stats = statsService.getEventDashboardStats(eventId);

            // Extract only revenue-related data
            Map<String, Object> revenueStats = Map.of(
                    "eventId", stats.get("eventId"),
                    "eventName", stats.get("eventName"),
                    "totalRevenue", stats.get("totalRevenue"),
                    "revenueByTicketType", stats.get("revenueByTicketType")
            );

            return ResponseEntity.ok(revenueStats);
        } catch (Exception e) {
            log.error("Error getting revenue stats: {}", e.getMessage(), e);
            return ResponseEntity.internalServerError().build();
        }
    }

    private final AnalyticsService analyticsService;

    /**
     * Get list of attendees who have been validated for an event
     * GET /api/v1/organiser/events/{eventId}/dashboard/attendees
     */
    @GetMapping("/attendees")
    public ResponseEntity<?> getValidatedAttendees(
            @AuthenticationPrincipal Jwt jwt,
            @PathVariable UUID eventId,
            Pageable pageable
    ) {
        UUID organiserId = UserFromJwt.parseUserId(jwt);
        log.info("Organiser {} requesting validated attendees for event {}",
                organiserId, eventId);

        try {
            Page<Map<String, Object>> attendees = analyticsService.getValidatedAttendees(
                    eventId,
                    organiserId,
                    pageable
            );
            return ResponseEntity.ok(attendees);
        } catch (IllegalStateException e) {
            return ResponseEntity.badRequest().body(Map.of(
                    "error", "Failed to get attendees",
                    "message", e.getMessage()
            ));
        } catch (Exception e) {
            log.error("Error getting validated attendees: {}", e.getMessage(), e);
            return ResponseEntity.internalServerError().build();
        }
    }
}
</file>

<file path="src/main/java/com/atharv/Event_Ticket_Platform/Controllers/PublishEventController.java">
package com.atharv.Event_Ticket_Platform.Controllers;

import com.atharv.Event_Ticket_Platform.Domain.DTO.EventDtos.PublishEventDto;
import com.atharv.Event_Ticket_Platform.Domain.Entity.Event;
import com.atharv.Event_Ticket_Platform.Domain.Mapper.EventMapper;
import com.atharv.Event_Ticket_Platform.Repository.EventRepo;
import com.atharv.Event_Ticket_Platform.Service.ServiceInterface.EventService;
import lombok.RequiredArgsConstructor;
import org.springframework.data.domain.Page;
import org.springframework.data.domain.Pageable;
import org.springframework.http.HttpStatus;
import org.springframework.http.ResponseEntity;
import org.springframework.web.bind.annotation.*;

import java.util.Optional;
import java.util.UUID;

@RestController
@RequiredArgsConstructor
@CrossOrigin(origins = "*", maxAge = 3600)
@RequestMapping(path ="/api/v1/published-events")
public class PublishEventController {
    private final EventRepo eventRepo;
    private final EventService eventService;
    private final EventMapper eventMapper;

    @GetMapping
    public ResponseEntity<Page<PublishEventDto>> publishEvent(Pageable pageable){
        Page<PublishEventDto> p=eventService.listPublishedEvents(pageable).map(eventMapper::toPublishEventDto);
        return new ResponseEntity<>(p, HttpStatus.OK);
    }

    @GetMapping("{eventID}")
    public ResponseEntity<PublishEventDto> getPublishedEventById(@PathVariable UUID eventID){
         Optional<Event> event=eventService.getPublishedEventById(eventID);
         if(event.isPresent()){
             return new ResponseEntity<>(eventMapper.toPublishEventDto(event.get()),HttpStatus.OK);
         }
         return ResponseEntity.noContent().build();
    }



}
</file>

<file path="src/main/java/com/atharv/Event_Ticket_Platform/Controllers/StaffValidationController.java">
package com.atharv.Event_Ticket_Platform.Controllers;

import com.atharv.Event_Ticket_Platform.Domain.DTO.TicketValidationDtos.*;
import com.atharv.Event_Ticket_Platform.Domain.Entity.Ticket;
import com.atharv.Event_Ticket_Platform.Domain.Entity.TicketValidation;
import com.atharv.Event_Ticket_Platform.Service.ServiceImpl.StaffTicketValidationService;
import com.atharv.Event_Ticket_Platform.Service.ServiceImpl.ValidationStatsService;
import com.atharv.Event_Ticket_Platform.util.UserFromJwt;
import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;
import org.springframework.data.domain.Page;
import org.springframework.data.domain.Pageable;
import org.springframework.http.ResponseEntity;
import org.springframework.security.access.prepost.PreAuthorize;
import org.springframework.security.core.annotation.AuthenticationPrincipal;
import org.springframework.security.oauth2.jwt.Jwt;
import org.springframework.web.bind.annotation.*;

import java.util.Map;
import java.util.UUID;

/**
 * üîí Staff-only endpoints for ticket validation
 * Staff can ONLY access these endpoints after logging in with their credentials
 */
@RestController
@RequestMapping("/api/v1/staff/validation")
@RequiredArgsConstructor
@Slf4j
@PreAuthorize("hasRole('STAFF')")
public class StaffValidationController {

    private final StaffTicketValidationService validationService;
    private final ValidationStatsService statsService;

    /**
     * ‚úÖ Staff scans QR code to validate ticket
     * POST /api/v1/staff/validation/scan
     *
     * Request Body:
     * {
     *   "qrCode": "ABC12345"
     * }
     */
    @PostMapping("/scan")
    public ResponseEntity<?> validateTicketByQR(
            @AuthenticationPrincipal Jwt jwt,
            @RequestBody Map<String, String> request
    ) {
        UUID staffUserId = UserFromJwt.parseUserId(jwt);
        String qrCode = request.get("qrCode");

        log.info("Staff {} scanning QR code: {}", staffUserId, qrCode);

        if (qrCode == null || qrCode.trim().isEmpty()) {
            return ResponseEntity.badRequest().body(Map.of(
                    "error", "Invalid request",
                    "message", "QR code is required"
            ));
        }

        try {
            TicketValidation validation = validationService.validateTicketByStaff(
                    qrCode.trim().toUpperCase(),
                    staffUserId
            );

            Ticket ticket = validation.getTicket();

            TicketValidationResponseDto response = TicketValidationResponseDto.builder()
                    .validationId(validation.getId())
                    .ticketId(ticket.getId())
                    .ticketTypeName(ticket.getTicketType().getName())
                    .attendeeName(ticket.getPurchaser().getName())
                    .attendeeEmail(ticket.getPurchaser().getEmail())
                    .eventName(ticket.getTicketType().getEvent().getName())
                    .validatedAt(validation.getValidatedAt())
                    .validatedBy(jwt.getClaimAsString("preferred_username"))
                    .message("‚úÖ Valid ticket! Entry granted.")
                    .build();

            return ResponseEntity.ok(response);

        } catch (IllegalStateException e) {
            log.warn("Validation failed: {}", e.getMessage());
            return ResponseEntity.badRequest().body(Map.of(
                    "error", "Validation failed",
                    "message", e.getMessage()
            ));
        } catch (Exception e) {
            log.error("Unexpected error during validation: {}", e.getMessage(), e);
            return ResponseEntity.internalServerError().body(Map.of(
                    "error", "Validation error",
                    "message", "An unexpected error occurred. Please try again."
            ));
        }
    }

    /**
     * ‚úÖ CORRECTED: Staff validates ticket manually by typing QR code
     * POST /api/v1/staff/validation/manual
     *
     * Use case: Attendee verbally provides QR code (e.g., "ABC12345")
     *
     * Request Body:
     * {
     *   "qrCode": "ABC12345"
     * }
     *
     * ‚ö†Ô∏è IMPORTANT: This still validates QR expiry and status!
     */
    @PostMapping("/manual")
    public ResponseEntity<?> validateTicketManually(
            @AuthenticationPrincipal Jwt jwt,
            @RequestBody Map<String, String> request
    ) {
        UUID staffUserId = UserFromJwt.parseUserId(jwt);
        String qrCode = request.get("qrCode");

        log.info("Staff {} attempting manual validation with QR code: {}", staffUserId, qrCode);

        if (qrCode == null || qrCode.trim().isEmpty()) {
            return ResponseEntity.badRequest().body(Map.of(
                    "error", "Invalid request",
                    "message", "QR code is required"
            ));
        }

        try {
            TicketValidation validation = validationService.validateTicketManually(
                    qrCode.trim().toUpperCase(),
                    staffUserId
            );

            Ticket ticket = validation.getTicket();

            TicketValidationResponseDto response = TicketValidationResponseDto.builder()
                    .validationId(validation.getId())
                    .ticketId(ticket.getId())
                    .ticketTypeName(ticket.getTicketType().getName())
                    .attendeeName(ticket.getPurchaser().getName())
                    .attendeeEmail(ticket.getPurchaser().getEmail())
                    .eventName(ticket.getTicketType().getEvent().getName())
                    .validatedAt(validation.getValidatedAt())
                    .validatedBy(jwt.getClaimAsString("preferred_username"))
                    .message("‚úÖ Ticket validated manually. Entry granted.")
                    .build();

            return ResponseEntity.ok(response);

        } catch (IllegalStateException e) {
            log.warn("Manual validation failed: {}", e.getMessage());
            return ResponseEntity.badRequest().body(Map.of(
                    "error", "Validation failed",
                    "message", e.getMessage()
            ));
        } catch (Exception e) {
            log.error("Unexpected error during manual validation: {}", e.getMessage(), e);
            return ResponseEntity.internalServerError().body(Map.of(
                    "error", "Validation error",
                    "message", "An unexpected error occurred. Please try again."
            ));
        }
    }

    /**
     * ‚úÖ CORRECTED: Search for ticket before manual validation
     * GET /api/v1/staff/validation/search?qrCode={qrCode}
     *
     * Staff can verify ticket details before validating manually
     */
    @GetMapping("/search")
    public ResponseEntity<?> searchTicket(
            @AuthenticationPrincipal Jwt jwt,
            @RequestParam String qrCode
    ) {
        UUID staffUserId = UserFromJwt.parseUserId(jwt);

        if (qrCode == null || qrCode.trim().isEmpty()) {
            return ResponseEntity.badRequest().body(Map.of(
                    "error", "Invalid request",
                    "message", "QR code is required"
            ));
        }

        try {
            Ticket ticket = validationService.searchTicketForValidation(
                    qrCode.trim().toUpperCase(),
                    staffUserId
            );

            return ResponseEntity.ok(Map.of(
                    "ticketId", ticket.getId(),
                    "attendeeName", ticket.getPurchaser().getName(),
                    "attendeeEmail", ticket.getPurchaser().getEmail(),
                    "ticketType", ticket.getTicketType().getName(),
                    "eventName", ticket.getTicketType().getEvent().getName(),
                    "status", ticket.getStatus().name(),
                    "price", ticket.getPrice()
            ));

        } catch (IllegalStateException e) {
            return ResponseEntity.badRequest().body(Map.of(
                    "error", "Ticket not found",
                    "message", e.getMessage()
            ));
        }
    }

    /**
     * ‚úÖ Get MY validation statistics as a staff member
     * GET /api/v1/staff/validation/stats
     */
    @GetMapping("/stats")
    public ResponseEntity<?> getMyValidationStats(@AuthenticationPrincipal Jwt jwt) {
        UUID staffUserId = UserFromJwt.parseUserId(jwt);

        try {
            var stats = statsService.getStaffPersonalStats(staffUserId);
            return ResponseEntity.ok(stats);
        } catch (Exception e) {
            log.error("Failed to get stats: {}", e.getMessage());
            return ResponseEntity.internalServerError().build();
        }
    }

    /**
     * üÜï Get my recent validation history (paginated)
     * GET /api/v1/staff/validation/my-history
     */
    @GetMapping("/my-history")
    public ResponseEntity<?> getMyValidationHistory(
            @AuthenticationPrincipal Jwt jwt,
            Pageable pageable
    ) {
        UUID staffUserId = UserFromJwt.parseUserId(jwt);

        try {
            Page<ValidationHistoryDto> history = statsService.getStaffValidationHistory(
                    staffUserId,
                    pageable
            );
            return ResponseEntity.ok(history);
        } catch (Exception e) {
            log.error("Failed to get validation history: {}", e.getMessage());
            return ResponseEntity.internalServerError().build();
        }
    }

    /**
     * üÜï Get my validations grouped by ticket type
     * GET /api/v1/staff/validation/stats/by-ticket-type
     */
    @GetMapping("/stats/by-ticket-type")
    public ResponseEntity<?> getMyStatsByTicketType(@AuthenticationPrincipal Jwt jwt) {
        UUID staffUserId = UserFromJwt.parseUserId(jwt);

        try {
            var stats = statsService.getStaffValidationsByTicketType(staffUserId);
            return ResponseEntity.ok(stats);
        } catch (Exception e) {
            log.error("Failed to get ticket type stats: {}", e.getMessage());
            return ResponseEntity.internalServerError().build();
        }
    }

    /**
     * üÜï Get my credential information
     * GET /api/v1/staff/validation/my-credentials
     */
    @GetMapping("/my-credentials")
    public ResponseEntity<?> getMyCredentials(@AuthenticationPrincipal Jwt jwt) {
        UUID staffUserId = UserFromJwt.parseUserId(jwt);

        try {
            var credentials = statsService.getStaffCredentialInfo(staffUserId);
            return ResponseEntity.ok(credentials);
        } catch (Exception e) {
            log.error("Failed to get credential info: {}", e.getMessage());
            return ResponseEntity.internalServerError().build();
        }
    }
}
</file>

<file path="src/main/java/com/atharv/Event_Ticket_Platform/Controllers/TicketController.java">
package com.atharv.Event_Ticket_Platform.Controllers;

import com.atharv.Event_Ticket_Platform.Domain.DTO.EventDtos.EventDtoForTicketPurchase;
import com.atharv.Event_Ticket_Platform.Domain.DTO.QrCodeDtos.QrCodeDetails;
import com.atharv.Event_Ticket_Platform.Domain.DTO.TicketDtos.TicketPurchasedDetails;
import com.atharv.Event_Ticket_Platform.Domain.DTO.TicketDtos.TicketPurchasedDto;
import com.atharv.Event_Ticket_Platform.Domain.DTO.TicketTypeDto.TicketTypeDetails;
import com.atharv.Event_Ticket_Platform.Domain.Entity.Event;
import com.atharv.Event_Ticket_Platform.Domain.Entity.Ticket;
import com.atharv.Event_Ticket_Platform.Domain.Entity.User;
import com.atharv.Event_Ticket_Platform.Domain.Mapper.EventMapper;
import com.atharv.Event_Ticket_Platform.Domain.Mapper.TicketMapper;
import com.atharv.Event_Ticket_Platform.Repository.TicketsRepo;
import com.atharv.Event_Ticket_Platform.Repository.UserRepo;
import com.atharv.Event_Ticket_Platform.Service.ServiceInterface.QrService;
import com.atharv.Event_Ticket_Platform.Service.ServiceInterface.TicketService;
import com.atharv.Event_Ticket_Platform.util.UserFromJwt;
import com.google.zxing.WriterException;
import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;
import org.apache.logging.log4j.Logger;
import org.springframework.data.domain.Page;
import org.springframework.data.domain.Pageable;
import org.springframework.http.HttpStatus;
import org.springframework.http.ResponseEntity;
import org.springframework.security.core.annotation.AuthenticationPrincipal;
import org.springframework.security.oauth2.jwt.Jwt;
import org.springframework.web.bind.annotation.*;

import java.io.IOException;
import java.util.List;
import java.util.UUID;

@RestController
@RequiredArgsConstructor
@Slf4j
@RequestMapping("/api/v1/tickets")
public class TicketController {
    private final TicketService ticketService;
    private final TicketMapper ticketMapper;
    private final EventMapper eventMapper;
    private final QrService qrService;

    @PostMapping("/purchase/{ticketTypeId}")
    public ResponseEntity<TicketPurchasedDto> purchaseTicket(@AuthenticationPrincipal Jwt jwt , @PathVariable Integer ticketTypeId){
        UUID purchaserId=UserFromJwt.parseUserId(jwt);
        log.info("User {} purchasing ticket type {}", purchaserId, ticketTypeId);
        Ticket purchasedTicket=ticketService.purchaseTicket(purchaserId,ticketTypeId);
        TicketPurchasedDto ticketPurchasedDto=ticketMapper.toTicketPuchasedDto(purchasedTicket);
        return new ResponseEntity<>(ticketPurchasedDto, HttpStatus.CREATED);
    }

    @GetMapping
    public ResponseEntity<Page<TicketPurchasedDto>> listPurchasedTicket(@AuthenticationPrincipal Jwt jwt , Pageable pageable){
        UUID userID = UserFromJwt.parseUserId(jwt);
        log.info(" listing all tickets for userid {} ",userID);
        Page<Ticket> ticketForUser=ticketService.listAllTicketsForThisUser(userID,pageable);
        Page<TicketPurchasedDto> ticketPurchasedDtos=ticketForUser.map(ticketMapper::toTicketPuchasedDto);
        return new ResponseEntity<>(ticketPurchasedDtos,HttpStatus.OK);
    }

    @GetMapping("{ticketId}")
    public ResponseEntity<TicketPurchasedDetails> TicketDetails(@AuthenticationPrincipal Jwt jwt, @PathVariable UUID ticketId){
        UUID userId = UserFromJwt.parseUserId(jwt);
        TicketPurchasedDetails ticketPurchasedDto=ticketService.getTicketDetails(userId,ticketId);
        return new ResponseEntity<>(ticketPurchasedDto,HttpStatus.OK);
    }

    @GetMapping("{ticketId}/qr")
    public ResponseEntity<QrCodeDetails> QrDetails(@AuthenticationPrincipal Jwt jwt, @PathVariable UUID ticketId){
        UUID userId = UserFromJwt.parseUserId(jwt);
        QrCodeDetails qrCodeDetails=qrService.qrCodeDetails(userId,ticketId);
        return new ResponseEntity<>(qrCodeDetails,HttpStatus.OK);
    }

    @PostMapping("/{ticketId}/qr")
    public ResponseEntity<byte[]> getQrCode(@AuthenticationPrincipal Jwt jwt,@PathVariable UUID ticketId) throws IOException, WriterException {
        UUID userId = UserFromJwt.parseUserId(jwt);
        byte[] qrGenerated= qrService.generateQrImage(userId,ticketId);
        return new ResponseEntity<>(qrGenerated,HttpStatus.OK);
    }














}
</file>

<file path="src/main/java/com/atharv/Event_Ticket_Platform/Domain/DTO/AnalyticDtos/EventAnalyticsDto.java">
package com.atharv.Event_Ticket_Platform.Domain.DTO.AnalyticDtos;

import lombok.AllArgsConstructor;
import lombok.Builder;
import lombok.Data;
import lombok.NoArgsConstructor;

import java.time.LocalDateTime;
import java.util.List;
import java.util.UUID;

@Data
@Builder
@AllArgsConstructor
@NoArgsConstructor
public class EventAnalyticsDto {
    private
    UUID eventId;
    private String eventName;
    private String eventStatus;
    private String eventType;
    private String venue;
    private LocalDateTime startTime;
    private LocalDateTime endTime;

    // Overall event metrics
    private Long totalTicketsSold;
    private Double totalRevenue;
    private Long totalAttendeesValidated;
    private Double overallAttendanceRate;

    // Breakdown by ticket type
    private List<TicketTypeAnalyticsDto> ticketTypeAnalytics;
}
</file>

<file path="src/main/java/com/atharv/Event_Ticket_Platform/Domain/DTO/AnalyticDtos/OrganiserCompleteAnalyticsDto.java">
package com.atharv.Event_Ticket_Platform.Domain.DTO.AnalyticDtos;

import lombok.AllArgsConstructor;
import lombok.Builder;
import lombok.Data;
import lombok.NoArgsConstructor;

import java.util.List;
import java.util.UUID;

@Data @NoArgsConstructor @AllArgsConstructor @Builder
public class OrganiserCompleteAnalyticsDto {
    private UUID organiserId;
    private String organiserName;
    private String organiserEmail;

    // Summary across all events
    private Integer totalEvents;
    private Integer publishedEvents;
    private Integer draftEvents;
    private Long totalTicketsSold;
    private Double totalRevenue;
    private Long totalAttendeesValidated;
    private Double averageAttendanceRate;

    // Per-event breakdown
    private List<EventAnalyticsDto> eventAnalytics;

    // Top performers
    private EventAnalyticsDto mostRevenueEvent;
    private EventAnalyticsDto mostTicketsSoldEvent;
    private EventAnalyticsDto bestAttendanceRateEvent;
}
</file>

<file path="src/main/java/com/atharv/Event_Ticket_Platform/Domain/DTO/AnalyticDtos/TicketTypeAnalyticsDto.java">
package com.atharv.Event_Ticket_Platform.Domain.DTO.AnalyticDtos;

import lombok.AllArgsConstructor;
import lombok.Builder;
import lombok.Data;
import lombok.NoArgsConstructor;

@Data
@Builder
@AllArgsConstructor
@NoArgsConstructor
 public class TicketTypeAnalyticsDto {
    private Integer ticketTypeId;
    private String ticketTypeName;
    private Double price;
    private Integer totalAvailable;
    private Long ticketsSold;
    private Double revenue;
    private Long attendeesValidated;
    private Double attendanceRate; // (validated / sold) * 100
    private Integer remainingTickets;
}
</file>

<file path="src/main/java/com/atharv/Event_Ticket_Platform/Domain/DTO/AnalyticDtos/TicketTypePerformanceDto.java">
package com.atharv.Event_Ticket_Platform.Domain.DTO.AnalyticDtos;

import lombok.AllArgsConstructor;
import lombok.Builder;
import lombok.Data;
import lombok.NoArgsConstructor;

@Data
@Builder
@AllArgsConstructor
@NoArgsConstructor
public class TicketTypePerformanceDto {
    private String ticketTypeName;
    private Long totalSold;
    private Double totalRevenue;
    private Long totalValidated;
    private Double averagePrice;
    private Integer numberOfEvents; // How many events use this ticket type
}
</file>

<file path="src/main/java/com/atharv/Event_Ticket_Platform/Domain/DTO/AnalyticDtos/ValidatedAttendeeResponse.java">
package com.atharv.Event_Ticket_Platform.Domain.DTO.AnalyticDtos;

import lombok.AllArgsConstructor;
import lombok.Builder;
import lombok.Getter;

import java.time.LocalDateTime;
import java.util.UUID;

@Getter
@Builder
@AllArgsConstructor
public class ValidatedAttendeeResponse {

    private UUID validationId;
    private LocalDateTime validatedAt;
    private String validationMethod;

    private UUID attendeeId;
    private String attendeeName;
    private String attendeeEmail;

    private UUID ticketId;
    private String ticketType;
    private double ticketPrice;
}
</file>

<file path="src/main/java/com/atharv/Event_Ticket_Platform/Domain/DTO/ErrorDtos/ErrorDto.java">
package com.atharv.Event_Ticket_Platform.Domain.DTO.ErrorDtos;

import lombok.AllArgsConstructor;
import lombok.Data;
import lombok.NoArgsConstructor;

@Data
@NoArgsConstructor
@AllArgsConstructor
public class ErrorDto {
    private String error;
}
</file>

<file path="src/main/java/com/atharv/Event_Ticket_Platform/Domain/DTO/EventDtos/CreateEventRequestDto.java">
package com.atharv.Event_Ticket_Platform.Domain.DTO.EventDtos;

import com.atharv.Event_Ticket_Platform.Domain.DTO.TicketTypeDto.CreateTicketTypeRequestDto;
import com.atharv.Event_Ticket_Platform.Domain.Enum.EventType;
import jakarta.validation.constraints.NotBlank;
import lombok.AllArgsConstructor;
import lombok.Data;
import lombok.NoArgsConstructor;

import java.time.LocalDateTime;
import java.util.ArrayList;
import java.util.List;

@Data
@NoArgsConstructor
@AllArgsConstructor
public class CreateEventRequestDto {

    @NotBlank(message = "event name is required")
    private String name;


    private LocalDateTime startTime;
    private LocalDateTime endTime;
    @NotBlank(message = "venue name is required")
    private String venue;

    private LocalDateTime salesStartDate;
    private LocalDateTime salesEndDate;

    private EventType eventType;

    private String description;
    private List<CreateTicketTypeRequestDto> ticketTypes = new ArrayList<>();


}
</file>

<file path="src/main/java/com/atharv/Event_Ticket_Platform/Domain/DTO/EventDtos/EventCreatedResponseDto.java">
package com.atharv.Event_Ticket_Platform.Domain.DTO.EventDtos;

import com.atharv.Event_Ticket_Platform.Domain.DTO.TicketTypeDto.TicketTypeCreatedResponseDto;
import com.atharv.Event_Ticket_Platform.Domain.Enum.EventStatus;
import com.atharv.Event_Ticket_Platform.Domain.Enum.EventType;
import lombok.AllArgsConstructor;
import lombok.Data;
import lombok.NoArgsConstructor;

import java.time.LocalDateTime;
import java.util.List;
import java.util.UUID;
@Data
@NoArgsConstructor
@AllArgsConstructor
public class EventCreatedResponseDto {
    private UUID id;
    private String name;
    private String description;
    private LocalDateTime startTime;
    private LocalDateTime endTime;
    private String venue;
    private LocalDateTime salesStartDate;
    private LocalDateTime salesEndDate;
    private EventStatus eventStatus;
    private List<TicketTypeCreatedResponseDto> ticketTypes;
    private EventType eventType;
    private LocalDateTime createdAt;
    private LocalDateTime updatedAt;

}
</file>

<file path="src/main/java/com/atharv/Event_Ticket_Platform/Domain/DTO/EventDtos/EventDtoForTicketPurchase.java">
package com.atharv.Event_Ticket_Platform.Domain.DTO.EventDtos;

import com.atharv.Event_Ticket_Platform.Domain.Entity.Event;
import lombok.AllArgsConstructor;
import lombok.Data;
import lombok.NoArgsConstructor;

import java.time.LocalDateTime;
import java.util.UUID;

@Data @AllArgsConstructor @NoArgsConstructor
public class EventDtoForTicketPurchase {
    private UUID id;
    private String name;
    private LocalDateTime startTime;
    private LocalDateTime endTime;

}
</file>

<file path="src/main/java/com/atharv/Event_Ticket_Platform/Domain/DTO/EventDtos/EventResponseDto.java">
package com.atharv.Event_Ticket_Platform.Domain.DTO.EventDtos;

import com.atharv.Event_Ticket_Platform.Domain.DTO.TicketTypeDto.TicketTypeCreatedResponseDto;
import com.atharv.Event_Ticket_Platform.Domain.Enum.EventStatus;
import com.atharv.Event_Ticket_Platform.Domain.Enum.EventType;
import lombok.AllArgsConstructor;
import lombok.Data;
import lombok.NoArgsConstructor;

import java.time.LocalDateTime;
import java.util.List;
import java.util.UUID;

@Data @NoArgsConstructor @AllArgsConstructor
public class EventResponseDto {
    private UUID id;
    private String name;
    private String description;
    private LocalDateTime startTime;
    private LocalDateTime endTime;
    private String venue;
    private LocalDateTime salesStartDate;
    private LocalDateTime salesEndDate;
    private EventStatus eventStatus;
    private List<TicketTypeCreatedResponseDto> ticketTypes;
    private EventType eventType;
    private LocalDateTime createdAt;
    private LocalDateTime updatedAt;
}
</file>

<file path="src/main/java/com/atharv/Event_Ticket_Platform/Domain/DTO/EventDtos/ListEventResponseDto.java">
package com.atharv.Event_Ticket_Platform.Domain.DTO.EventDtos;

import com.atharv.Event_Ticket_Platform.Domain.DTO.TicketTypeDto.ListEventTicketTypeResponseDto;
import com.atharv.Event_Ticket_Platform.Domain.Entity.TicketType;
import com.atharv.Event_Ticket_Platform.Domain.Enum.EventStatus;
import com.atharv.Event_Ticket_Platform.Domain.Enum.EventType;
import lombok.AllArgsConstructor;
import lombok.Data;
import lombok.NoArgsConstructor;

import java.time.LocalDateTime;
import java.util.ArrayList;
import java.util.List;
import java.util.UUID;

@Data @AllArgsConstructor @NoArgsConstructor
public class ListEventResponseDto {
    private UUID id;
    private String name;
    private String description;
    private LocalDateTime startTime;
    private LocalDateTime endTime;
    private String venue;
    private LocalDateTime salesStartDate;
    private LocalDateTime salesEndDate;
    private EventType eventType;
    private EventStatus eventStatus;
    private List<ListEventTicketTypeResponseDto> ticketTypes=new ArrayList<>();
}
</file>

<file path="src/main/java/com/atharv/Event_Ticket_Platform/Domain/DTO/EventDtos/PublishEventDto.java">
package com.atharv.Event_Ticket_Platform.Domain.DTO.EventDtos;

import com.atharv.Event_Ticket_Platform.Domain.DTO.TicketTypeDto.ListEventTicketTypeResponseDto;
import com.atharv.Event_Ticket_Platform.Domain.Enum.EventStatus;
import com.atharv.Event_Ticket_Platform.Domain.Enum.EventType;
import lombok.AllArgsConstructor;
import lombok.Data;
import lombok.NoArgsConstructor;

import java.time.LocalDateTime;
import java.util.ArrayList;
import java.util.List;
import java.util.UUID;

@Data
@AllArgsConstructor
@NoArgsConstructor
public class PublishEventDto {
    private UUID id;
    private String name;
    private String description;
    private LocalDateTime startTime;
    private LocalDateTime endTime;
    private String venue;
    private LocalDateTime salesStartDate;
    private LocalDateTime salesEndDate;

    private EventStatus eventStatus;
    private EventType eventType;
    private List<ListEventTicketTypeResponseDto> ticketTypes = new ArrayList<>();
    private String imageUrl; // Optional: for event images
}
</file>

<file path="src/main/java/com/atharv/Event_Ticket_Platform/Domain/DTO/EventDtos/UpdatedEventResponseDto.java">
package com.atharv.Event_Ticket_Platform.Domain.DTO.EventDtos;

import com.atharv.Event_Ticket_Platform.Domain.DTO.TicketTypeDto.UpdatedTicketTypeResponseDto;
import com.atharv.Event_Ticket_Platform.Domain.Entity.TicketType;
import com.atharv.Event_Ticket_Platform.Domain.Enum.EventType;
import lombok.AllArgsConstructor;
import lombok.Data;
import lombok.NoArgsConstructor;

import java.time.LocalDateTime;
import java.util.List;
import java.util.UUID;

@Data @NoArgsConstructor @AllArgsConstructor
public class UpdatedEventResponseDto {
    private UUID id;
    private String name;
    private String description;
    private LocalDateTime startTime;
    private LocalDateTime endTime;
    private EventType eventType;
    private String venue;
    private LocalDateTime salesStartDate;
    private LocalDateTime salesEndDate;
    private List<UpdatedTicketTypeResponseDto> ticketTypes;

}
</file>

<file path="src/main/java/com/atharv/Event_Ticket_Platform/Domain/DTO/EventDtos/UpdateEventRequestDto.java">
package com.atharv.Event_Ticket_Platform.Domain.DTO.EventDtos;

import com.atharv.Event_Ticket_Platform.Domain.DTO.TicketTypeDto.UpdateTicketTypeRequestDto;

import com.atharv.Event_Ticket_Platform.Domain.Enum.EventType;
import lombok.AllArgsConstructor;
import lombok.Data;
import lombok.NoArgsConstructor;

import java.time.LocalDateTime;
import java.util.ArrayList;
import java.util.List;
import java.util.UUID;

@Data @AllArgsConstructor @NoArgsConstructor
public class UpdateEventRequestDto {
    private String name;
    private String description;
    private LocalDateTime startTime;
    private LocalDateTime endTime;
    private String venue;
    private LocalDateTime salesStartDate;
    private LocalDateTime salesEndDate;
    private EventType eventType;
    private List<UpdateTicketTypeRequestDto> ticketTypes=new ArrayList<>();

}
</file>

<file path="src/main/java/com/atharv/Event_Ticket_Platform/Domain/DTO/QrCodeDtos/QrCodeDetails.java">
package com.atharv.Event_Ticket_Platform.Domain.DTO.QrCodeDtos;

import com.atharv.Event_Ticket_Platform.Domain.Enum.QrCodeStatus;
import lombok.AllArgsConstructor;
import lombok.Data;
import lombok.NoArgsConstructor;

import java.time.LocalDateTime;
import java.util.UUID;

@Data @AllArgsConstructor @NoArgsConstructor
public class QrCodeDetails {
    private UUID id;
    private String publicCode;
    private QrCodeStatus qrCodeStatus;
    private LocalDateTime generatedDateTime;
}
</file>

<file path="src/main/java/com/atharv/Event_Ticket_Platform/Domain/DTO/StaffDtos/GenerateStaffRequestDto.java">
package com.atharv.Event_Ticket_Platform.Domain.DTO.StaffDtos;

import lombok.AllArgsConstructor;
import lombok.Builder;
import lombok.Data;
import lombok.NoArgsConstructor;

@Data
@AllArgsConstructor
@NoArgsConstructor
@Builder
public class GenerateStaffRequestDto {
    private Integer count; // Number of staff to generate
    private Integer validityHours; // How long credentials are valid
}
</file>

<file path="src/main/java/com/atharv/Event_Ticket_Platform/Domain/DTO/StaffDtos/GenerateStaffResponseDto.java">
package com.atharv.Event_Ticket_Platform.Domain.DTO.StaffDtos;

import lombok.AllArgsConstructor;
import lombok.Builder;
import lombok.Data;
import lombok.NoArgsConstructor;

import java.time.LocalDateTime;
import java.util.List;
import java.util.UUID;

@Data
@AllArgsConstructor
@NoArgsConstructor
@Builder
public class GenerateStaffResponseDto {
    private String message;
    private UUID organiserId;
    private UUID eventId;
    private Integer staffCount;
    private Integer validityHours;
    private LocalDateTime validFrom;
    private LocalDateTime validUntil;
    private List<StaffCredentialWithPasswordDto> credentials;
}
</file>

<file path="src/main/java/com/atharv/Event_Ticket_Platform/Domain/DTO/StaffDtos/StaffCredentialsDto.java">
package com.atharv.Event_Ticket_Platform.Domain.DTO.StaffDtos;

import lombok.AllArgsConstructor;
import lombok.Builder;
import lombok.Data;
import lombok.NoArgsConstructor;

import java.time.LocalDateTime;
import java.util.UUID;


@Data @AllArgsConstructor @NoArgsConstructor @Builder
public class StaffCredentialsDto {
    private Long id;
    private UUID staffUserId;
    private String username;
    private String email;
    private Boolean isActive;
    private LocalDateTime validFrom;
    private LocalDateTime validUntil;
    private Boolean isExpired;
    private LocalDateTime createdAt;
    private LocalDateTime lastLogin;
}
</file>

<file path="src/main/java/com/atharv/Event_Ticket_Platform/Domain/DTO/StaffDtos/StaffCredentialWithPasswordDto.java">
package com.atharv.Event_Ticket_Platform.Domain.DTO.StaffDtos;

import lombok.AllArgsConstructor;
import lombok.Builder;
import lombok.Data;
import lombok.NoArgsConstructor;

import java.time.LocalDateTime;
import java.util.UUID;

@Data
@AllArgsConstructor
@NoArgsConstructor
@Builder
public class StaffCredentialWithPasswordDto {
    private UUID staffUserId;
    private String username;
    private String password; // Only returned during generation
    private String email;
    private LocalDateTime validFrom;
    private LocalDateTime validUntil;
}
</file>

<file path="src/main/java/com/atharv/Event_Ticket_Platform/Domain/DTO/TicketDtos/TicketPurchasedDetails.java">
package com.atharv.Event_Ticket_Platform.Domain.DTO.TicketDtos;

import com.atharv.Event_Ticket_Platform.Domain.DTO.QrCodeDtos.QrCodeDetails;
import com.atharv.Event_Ticket_Platform.Domain.DTO.TicketTypeDto.TicketTypeDetails;
import com.atharv.Event_Ticket_Platform.Domain.Entity.QrCode;
import com.atharv.Event_Ticket_Platform.Domain.Enum.TicketStatus;
import lombok.AllArgsConstructor;
import lombok.Data;
import lombok.NoArgsConstructor;

import java.time.LocalDateTime;
import java.util.UUID;

@Data @NoArgsConstructor @AllArgsConstructor
public class TicketPurchasedDetails {
    private UUID id;
    private Double price;
    private TicketStatus status;
    private TicketTypeDetails ticketType;
    private LocalDateTime purchasedAt;
//    private QrCodeDetails qrCode;
}
</file>

<file path="src/main/java/com/atharv/Event_Ticket_Platform/Domain/DTO/TicketDtos/TicketPurchasedDto.java">
package com.atharv.Event_Ticket_Platform.Domain.DTO.TicketDtos;

import com.atharv.Event_Ticket_Platform.Domain.DTO.EventDtos.EventDtoForTicketPurchase;
import com.atharv.Event_Ticket_Platform.Domain.DTO.TicketTypeDto.TicketTypeDtoForTicketPurchase;
import com.atharv.Event_Ticket_Platform.Domain.Entity.TicketType;
import com.atharv.Event_Ticket_Platform.Domain.Enum.TicketStatus;
import lombok.AllArgsConstructor;
import lombok.Data;
import lombok.NoArgsConstructor;

import java.util.UUID;

@Data @AllArgsConstructor @NoArgsConstructor
public class TicketPurchasedDto {
    private UUID id;
    private Double price;
    private TicketStatus status;
    private TicketTypeDtoForTicketPurchase ticketType;
    private EventDtoForTicketPurchase event;
}
</file>

<file path="src/main/java/com/atharv/Event_Ticket_Platform/Domain/DTO/TicketDtos/TicketValidationResponseDto.java">
package com.atharv.Event_Ticket_Platform.Domain.DTO.TicketDtos;

import lombok.AllArgsConstructor;
import lombok.Builder;
import lombok.Data;
import lombok.NoArgsConstructor;

import java.time.LocalDateTime;
import java.util.UUID;

@Data
@AllArgsConstructor
@NoArgsConstructor
@Builder
public class TicketValidationResponseDto {
    private UUID validationId;
    private UUID ticketId;
    private String ticketTypeName;
    private String attendeeName;
    private String attendeeEmail;
    private String eventName;
    private LocalDateTime validatedAt;
    private String validatedBy; // Staff username
    private String message;
}
</file>

<file path="src/main/java/com/atharv/Event_Ticket_Platform/Domain/DTO/TicketTypeDto/CreateTicketTypeRequestDto.java">
package com.atharv.Event_Ticket_Platform.Domain.DTO.TicketTypeDto;

import jakarta.validation.constraints.NotBlank;
import jakarta.validation.constraints.NotNull;
import jakarta.validation.constraints.PositiveOrZero;
import lombok.AllArgsConstructor;
import lombok.Data;
import lombok.NoArgsConstructor;

@Data
@NoArgsConstructor
@AllArgsConstructor
public class CreateTicketTypeRequestDto {
    @NotBlank(message = "ticket type name is required")
    private String name;

    @NotNull(message = "price is required")
    @PositiveOrZero(message = "price must be 0 or greater")
    private Double price;

    private  String description;
    private Integer totalAvailable;

}
</file>

<file path="src/main/java/com/atharv/Event_Ticket_Platform/Domain/DTO/TicketTypeDto/ListEventTicketTypeResponseDto.java">
package com.atharv.Event_Ticket_Platform.Domain.DTO.TicketTypeDto;

import lombok.AllArgsConstructor;
import lombok.Data;
import lombok.NoArgsConstructor;

@Data @NoArgsConstructor @AllArgsConstructor
public class ListEventTicketTypeResponseDto {
    private Integer id;
    private String name;
    private Double price;
    private Integer totalAvailable;

}
</file>

<file path="src/main/java/com/atharv/Event_Ticket_Platform/Domain/DTO/TicketTypeDto/TicketTypeCreatedResponseDto.java">
package com.atharv.Event_Ticket_Platform.Domain.DTO.TicketTypeDto;

import lombok.AllArgsConstructor;
import lombok.Data;
import lombok.NoArgsConstructor;

import java.time.LocalDateTime;

@Data
@NoArgsConstructor
@AllArgsConstructor
public class TicketTypeCreatedResponseDto {
    private Integer id;
    private String name;
    private Integer totalAvailable;
    private String description;
    private Double price;
    private LocalDateTime createdAt;
    private LocalDateTime updatedAt;

}
</file>

<file path="src/main/java/com/atharv/Event_Ticket_Platform/Domain/DTO/TicketTypeDto/TicketTypeDetails.java">
package com.atharv.Event_Ticket_Platform.Domain.DTO.TicketTypeDto;

import lombok.AllArgsConstructor;
import lombok.Data;
import lombok.NoArgsConstructor;

@Data @AllArgsConstructor @NoArgsConstructor
public class TicketTypeDetails {
    private Integer id;
    private String name;
    private Double price;
}
</file>

<file path="src/main/java/com/atharv/Event_Ticket_Platform/Domain/DTO/TicketTypeDto/TicketTypeDtoForTicketPurchase.java">
package com.atharv.Event_Ticket_Platform.Domain.DTO.TicketTypeDto;

import com.atharv.Event_Ticket_Platform.Domain.Entity.Event;
import lombok.AllArgsConstructor;
import lombok.Data;
import lombok.NoArgsConstructor;

@Data @AllArgsConstructor @NoArgsConstructor
public class TicketTypeDtoForTicketPurchase {
    private Integer id;
    private String name;
    private Integer totalAvailable;
    private Double price;

}
</file>

<file path="src/main/java/com/atharv/Event_Ticket_Platform/Domain/DTO/TicketTypeDto/TicketTypeRevenueDto.java">
package com.atharv.Event_Ticket_Platform.Domain.DTO.TicketTypeDto;

import lombok.AllArgsConstructor;
import lombok.Builder;
import lombok.Data;
import lombok.NoArgsConstructor;

@Data @AllArgsConstructor @NoArgsConstructor @Builder
public class TicketTypeRevenueDto {
    private Integer ticketTypeId;
    private String ticketTypeName;
    private long ticketsSold;
    private double revenue;
    private double averagePrice;
}
</file>

<file path="src/main/java/com/atharv/Event_Ticket_Platform/Domain/DTO/TicketTypeDto/UpdatedTicketTypeResponseDto.java">
package com.atharv.Event_Ticket_Platform.Domain.DTO.TicketTypeDto;

import lombok.AllArgsConstructor;
import lombok.Data;
import lombok.NoArgsConstructor;

@Data @NoArgsConstructor @AllArgsConstructor
public class UpdatedTicketTypeResponseDto {
    private Integer id;
    private String name;
    private Integer totalAvailable;
    private String description;
    private Double price;

}
</file>

<file path="src/main/java/com/atharv/Event_Ticket_Platform/Domain/DTO/TicketTypeDto/UpdateTicketTypeRequestDto.java">
package com.atharv.Event_Ticket_Platform.Domain.DTO.TicketTypeDto;

import lombok.AllArgsConstructor;
import lombok.Data;
import lombok.NoArgsConstructor;

import java.util.UUID;

@Data @NoArgsConstructor @AllArgsConstructor
public class UpdateTicketTypeRequestDto {
    private Integer id;
    private String name;
    private Integer totalAvailable;
    private String description;
    private Double price;

}
</file>

<file path="src/main/java/com/atharv/Event_Ticket_Platform/Domain/DTO/TicketValidationDtos/EventValidationStatsDto.java">
package com.atharv.Event_Ticket_Platform.Domain.DTO.TicketValidationDtos;

import lombok.AllArgsConstructor;
import lombok.Builder;
import lombok.Data;
import lombok.NoArgsConstructor;

import java.util.UUID;

@Data
@Builder @AllArgsConstructor @NoArgsConstructor
public class EventValidationStatsDto {
    private UUID eventId;
    private String eventName;
    private long totalTicketsSold;
    private long totalValidated;
    private long remainingAttendees;
}
</file>

<file path="src/main/java/com/atharv/Event_Ticket_Platform/Domain/DTO/TicketValidationDtos/StaffValidationStatsDto.java">
package com.atharv.Event_Ticket_Platform.Domain.DTO.TicketValidationDtos;

import lombok.AllArgsConstructor;
import lombok.Builder;
import lombok.Data;
import lombok.NoArgsConstructor;

import java.util.UUID;

@Data
@Builder @AllArgsConstructor @NoArgsConstructor
public class StaffValidationStatsDto {
    private UUID staffUserId;
    private String staffUsername;
    private long validatedCount;
}
</file>

<file path="src/main/java/com/atharv/Event_Ticket_Platform/Domain/DTO/TicketValidationDtos/TicketTypeAttendanceDto.java">
package com.atharv.Event_Ticket_Platform.Domain.DTO.TicketValidationDtos;

import lombok.AllArgsConstructor;
import lombok.Builder;
import lombok.Data;
import lombok.NoArgsConstructor;

import java.util.UUID;

@Data
@Builder @NoArgsConstructor @AllArgsConstructor
public class TicketTypeAttendanceDto {
    private Integer ticketTypeId;
    private String ticketTypeName;
    private long validatedCount;
}
</file>

<file path="src/main/java/com/atharv/Event_Ticket_Platform/Domain/DTO/TicketValidationDtos/TicketValidationResponseDto.java">
package com.atharv.Event_Ticket_Platform.Domain.DTO.TicketValidationDtos;

import com.atharv.Event_Ticket_Platform.Domain.Entity.Staff;
import lombok.AllArgsConstructor;
import lombok.Builder;
import lombok.Data;
import lombok.NoArgsConstructor;

import java.time.LocalDateTime;
import java.util.UUID;

/**
 * Response DTO when staff successfully validates a ticket
 */
@Data @AllArgsConstructor @NoArgsConstructor
@Builder
public class TicketValidationResponseDto {
    private UUID validationId;
    private UUID ticketId;
    private String ticketTypeName;
    private String attendeeName;
    private String attendeeEmail;
    private String eventName;
    private LocalDateTime validatedAt;
    private String validatedBy;  Staff username;
    private String message;
}
</file>

<file path="src/main/java/com/atharv/Event_Ticket_Platform/Domain/DTO/TicketValidationDtos/ValidationHistoryDto.java">
package com.atharv.Event_Ticket_Platform.Domain.DTO.TicketValidationDtos;

import lombok.AllArgsConstructor;
import lombok.Builder;
import lombok.Data;
import lombok.NoArgsConstructor;

import java.time.LocalDateTime;
import java.util.UUID;

/**
 * DTO for displaying validation history
 * Shows recent validations performed by staff
 */
@Data
@AllArgsConstructor
@NoArgsConstructor
@Builder
public class ValidationHistoryDto {
    private UUID validationId;
    private UUID ticketId;
    private String ticketTypeName;
    private String attendeeName;
    private String attendeeEmail;
    private String validationMethod; // QR or MANUAL
    private String validationStatus; // VALID, INVALID, etc.
    private LocalDateTime validatedAt;
    private String qrCode; // For display purposes (last 4 chars)
}
</file>

<file path="src/main/java/com/atharv/Event_Ticket_Platform/Domain/Entity/Event.java">
package com.atharv.Event_Ticket_Platform.Domain.Entity;


import com.atharv.Event_Ticket_Platform.Domain.Enum.EventStatus;
import com.atharv.Event_Ticket_Platform.Domain.Enum.EventType;
import jakarta.persistence.*;
import lombok.*;
import org.springframework.data.annotation.CreatedDate;
import org.springframework.data.annotation.LastModifiedDate;
import org.springframework.data.jpa.domain.support.AuditingEntityListener;

import java.time.LocalDateTime;
import java.util.ArrayList;
import java.util.List;
import java.util.Objects;
import java.util.UUID;

@Entity
@Table(name="event")
@EntityListeners(AuditingEntityListener.class)  // ‚Üê ADD THIS LINE
@Getter @Setter @NoArgsConstructor @AllArgsConstructor
@Builder
public class Event {
    @Id
    @GeneratedValue(strategy = GenerationType.UUID)
    @Column(name="id",updatable = false,nullable = false)
    private UUID id;

    @Column(name="name",nullable = false)
    private String name;

    private String description;

    @Column(nullable = true)
    private LocalDateTime startTime;

    @Column(nullable = true)
    private LocalDateTime endTime;

    @Column(nullable = false)
    private String venue;

    @Column(nullable = true)
    private LocalDateTime salesStartDate;

    @Column(nullable = true)
    private LocalDateTime salesEndDate;

    @Column(nullable = true)
    @Enumerated(EnumType.STRING) // if this statement is not mentioned then numeric position of enum value is stored in db
    private EventStatus eventStatus;

    @ManyToOne(fetch=FetchType.LAZY)
    @JoinColumn(name="organiser_id",nullable = false) // organiser_id is foreign key in Event table
    private User organiser;

    @ManyToMany(mappedBy = "attendingEvents")
    private List<User> attendees=new ArrayList<>();

    @ManyToMany(mappedBy = "staffingEvents")
    private List<User> staff = new ArrayList<>();

    @OneToMany(mappedBy = "event",cascade = CascadeType.ALL)
    private List<TicketType> ticketTypes;

    @Column(nullable = true)
    @Enumerated(EnumType.STRING)
    private EventType eventType;

    @CreatedDate
    @Column(name="created_at",nullable=false , updatable = false)
    private LocalDateTime createdAt;

    @LastModifiedDate
    @Column(name="updated_at")
    private LocalDateTime updatedAt;

    @Override
    public boolean equals(Object o) {
        if (o == null || getClass() != o.getClass()) return false;
        Event event = (Event) o;
        return Objects.equals(id, event.id) ;
    }

    @Override
    public int hashCode() {
        return Objects.hash(id);
    }
}
</file>

<file path="src/main/java/com/atharv/Event_Ticket_Platform/Domain/Entity/QrCode.java">
package com.atharv.Event_Ticket_Platform.Domain.Entity;


import com.atharv.Event_Ticket_Platform.Domain.Enum.QrCodeStatus;
import jakarta.persistence.*;
import lombok.*;
import org.springframework.data.annotation.CreatedDate;
import org.springframework.data.annotation.LastModifiedDate;
import org.springframework.data.jpa.domain.support.AuditingEntityListener;

import java.time.LocalDateTime;
import java.util.Objects;
import java.util.UUID;

@Entity
@EntityListeners(AuditingEntityListener.class)
@Table(name="qr_codes")
@Getter @Setter @AllArgsConstructor @NoArgsConstructor @Builder
public class QrCode {
    @Id
    @GeneratedValue(strategy = GenerationType.UUID)
    private UUID id;

    @Column(name = "public_code", unique = true, nullable = false, length = 8)
    private String publicCode;

    @Enumerated(EnumType.STRING)
    private QrCodeStatus qrCodeStatus;

    @Column(nullable = false)
    private LocalDateTime generatedDateTime;

    @ManyToOne(fetch = FetchType.LAZY)
    @JoinColumn(name="ticket_id")
    private Ticket ticket;

    @CreatedDate
    @Column(name="created_at",nullable=false)
    private LocalDateTime createdAt;

    @LastModifiedDate
    @Column(name="updated_at")
    private LocalDateTime updatedAt;

    @Override
    public boolean equals(Object o) {
        if (o == null || getClass() != o.getClass()) return false;
        QrCode qrCode = (QrCode) o;
        return Objects.equals(id, qrCode.id) && qrCodeStatus == qrCode.qrCodeStatus && Objects.equals(generatedDateTime, qrCode.generatedDateTime) && Objects.equals(createdAt, qrCode.createdAt) && Objects.equals(updatedAt, qrCode.updatedAt);
    }

    @Override
    public int hashCode() {
        return Objects.hash(id, qrCodeStatus, generatedDateTime, createdAt, updatedAt);
    }
}
</file>

<file path="src/main/java/com/atharv/Event_Ticket_Platform/Domain/Entity/Staff.java">
package com.atharv.Event_Ticket_Platform.Domain.Entity;

import jakarta.persistence.*;
import lombok.*;
import org.springframework.data.annotation.CreatedDate;
import org.springframework.data.jpa.domain.support.AuditingEntityListener;

import java.time.LocalDateTime;
import java.util.Objects;
import java.util.UUID;

@Entity
@EntityListeners(AuditingEntityListener.class)
@Table(name="staff")
@Getter @Setter @NoArgsConstructor @AllArgsConstructor @Builder
public class Staff {
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;

    @Column(name = "staff_user_id", nullable = false, unique = true)
    private UUID staffUserId; // The Keycloak user ID

    @Column(nullable = false)
    private UUID eventId;  // ‚úÖ Links staff to specific event

    @Column(nullable = false)
    private String username;

    @Column(nullable = false)
    private String email;

    @Column(name = "created_by_organiser_id", nullable = false)
    private UUID createdByOrganiserId;

    @Column(name = "is_active")
    private Boolean isActive = true;

    // ‚úÖ NEW: Validity period for staff credentials
    @Column(name = "valid_from", nullable = false)
    private LocalDateTime validFrom;

    @Column(name = "valid_until", nullable = false)
    private LocalDateTime validUntil;

    @CreatedDate
    @Column(name = "created_at", nullable = false, updatable = false)
    private LocalDateTime createdAt;

    @Column(name = "last_login")
    private LocalDateTime lastLogin;

    // ‚úÖ Helper method to check if credentials are still valid
    @Transient
    public boolean isExpired() {
        return LocalDateTime.now().isAfter(validUntil);
    }

    @Transient
    public boolean isValidNow() {
        LocalDateTime now = LocalDateTime.now();
        return isActive &&
                !now.isBefore(validFrom) &&
                !now.isAfter(validUntil);
    }

    @Override
    public boolean equals(Object o) {
        if (this == o) return true;
        if (!(o instanceof Staff)) return false;
        Staff that = (Staff) o;
        return Objects.equals(staffUserId, that.staffUserId);
    }

    @Override
    public int hashCode() {
        return Objects.hash(staffUserId);
    }
}
</file>

<file path="src/main/java/com/atharv/Event_Ticket_Platform/Domain/Entity/Ticket.java">
package com.atharv.Event_Ticket_Platform.Domain.Entity;


import com.atharv.Event_Ticket_Platform.Domain.Enum.TicketStatus;
import jakarta.persistence.*;
import lombok.*;
import org.springframework.data.annotation.CreatedDate;
import org.springframework.data.annotation.LastModifiedDate;
import org.springframework.data.jpa.domain.support.AuditingEntityListener;

import java.time.LocalDateTime;
import java.util.ArrayList;
import java.util.List;
import java.util.Objects;
import java.util.UUID;

@Entity
@EntityListeners(AuditingEntityListener.class)
@Table(name="ticket")
@Getter @Setter @AllArgsConstructor @NoArgsConstructor @Builder
public class Ticket {
    @Id
    @GeneratedValue(strategy = GenerationType.UUID)
    @Column(name="id", nullable=false, updatable=false)
    private UUID id;


    @Column(nullable = false)
    private Double price;

    @Enumerated(EnumType.STRING)
    @Column(nullable = false)
    private TicketStatus status;

    @ManyToOne(fetch = FetchType.LAZY)
    @JoinColumn(name="ticket_type_id")
    private TicketType ticketType;

    @ManyToOne(fetch=FetchType.LAZY)
    @JoinColumn(name="purchaser_id")
    private User purchaser;

    // todo : validation
    @OneToMany(mappedBy = "ticket")
    private List<TicketValidation> ticketValidations=new ArrayList<>();

    // todo : QrCode
    @OneToMany(mappedBy = "ticket",cascade = CascadeType.ALL)
    private List<QrCode> qrCodes=new ArrayList<>();


    @CreatedDate
    @Column(name="created_at",nullable=false)
    private LocalDateTime createdAt;

    @LastModifiedDate
    @Column(name="updated_at")
    private LocalDateTime updatedAt;

    @Override
    public boolean equals(Object o) {
        if (o == null || getClass() != o.getClass()) return false;
        Ticket ticket1 = (Ticket) o;
        return Objects.equals(id, ticket1.id) && Objects.equals(price, ticket1.price) && status == ticket1.status && Objects.equals(createdAt, ticket1.createdAt) && Objects.equals(updatedAt, ticket1.updatedAt);
    }

    @Override
    public int hashCode() {
        return Objects.hash(id, price, status, createdAt, updatedAt);
    }
}
</file>

<file path="src/main/java/com/atharv/Event_Ticket_Platform/Domain/Entity/TicketType.java">
package com.atharv.Event_Ticket_Platform.Domain.Entity;


import jakarta.persistence.*;
import jakarta.persistence.criteria.Fetch;
import lombok.*;
import org.springframework.data.annotation.CreatedDate;
import org.springframework.data.annotation.LastModifiedDate;
import org.springframework.data.jpa.domain.support.AuditingEntityListener;

import java.time.LocalDateTime;
import java.util.List;
import java.util.Objects;
import java.util.UUID;

@Entity
@EntityListeners(AuditingEntityListener.class)
@Table(name="ticket_type")
@Getter @Setter @AllArgsConstructor @NoArgsConstructor @Builder
public class TicketType {
    @Id
    @Column(name="id",updatable = false,nullable = false)
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Integer id;

    @Column(nullable = false)
    private String name;

    @Column(name="total_available")
    private Integer totalAvailable;


    private String description;

    @Column(nullable = false)
    private Double price;

    @ManyToOne(fetch = FetchType.LAZY)
    @JoinColumn(name="event_id")
    private Event event;

    @OneToMany(mappedBy = "ticketType")
    private List<Ticket> ticket;

    @CreatedDate
    @Column(name="created_at",nullable=false)
    private LocalDateTime createdAt;

    @LastModifiedDate
    @Column(name="updated_at")
    private LocalDateTime updatedAt;

    @Override
    public boolean equals(Object o) {
        if (this == o) return true;
        if (!(o instanceof TicketType)) return false;
        TicketType that = (TicketType) o;
        return id != null && id.equals(that.id);
    }

    @Override
    public int hashCode() {
        return getClass().hashCode();
    }

}
</file>

<file path="src/main/java/com/atharv/Event_Ticket_Platform/Domain/Entity/TicketValidation.java">
package com.atharv.Event_Ticket_Platform.Domain.Entity;

import com.atharv.Event_Ticket_Platform.Domain.Enum.TicketStatus;
import com.atharv.Event_Ticket_Platform.Domain.Enum.TicketValidationMethod;
import com.atharv.Event_Ticket_Platform.Domain.Enum.TicketValidationStatus;
import jakarta.persistence.*;
import lombok.*;
import org.springframework.data.annotation.CreatedDate;
import org.springframework.data.annotation.LastModifiedDate;
import org.springframework.data.jpa.domain.support.AuditingEntityListener;

import java.time.LocalDateTime;
import java.util.Objects;
import java.util.UUID;

@Entity
@EntityListeners(AuditingEntityListener.class)
@Table(name="ticket_validation")
@Getter @Setter @AllArgsConstructor @NoArgsConstructor @Builder
public class TicketValidation {
    @Id
    @Column(nullable = false,updatable = false)
    @GeneratedValue(strategy = GenerationType.UUID)
    private UUID id;

    @Enumerated(EnumType.STRING)
    @Column(nullable = false,updatable = false)
    private TicketValidationStatus validationStatus;

    @Enumerated(EnumType.STRING)
    private TicketValidationMethod ValidationMethod;

    @ManyToOne(fetch = FetchType.EAGER)
    @JoinColumn(name="ticket_id")
    private Ticket ticket;

    @ManyToOne(fetch = FetchType.LAZY, optional = false)
    @JoinColumn(name = "event_id", nullable = false)
    private Event event;

    @ManyToOne(fetch = FetchType.LAZY, optional = false)
    @JoinColumn(name = "staff_id", nullable = false)
    private Staff staff;

    @Column(name="created_at",nullable=false)
    private LocalDateTime validatedAt;

    @CreatedDate
    @Column(name="validated_at",nullable=false,updatable = false)
    private LocalDateTime createdAt;

    @LastModifiedDate
    @Column(name="updated_at")
    private LocalDateTime updatedAt;

    @Override
    public boolean equals(Object o) {
        if (o == null || getClass() != o.getClass()) return false;
        TicketValidation that = (TicketValidation) o;
        return Objects.equals(id, that.id) && Objects.equals(validatedAt, that.validatedAt) && Objects.equals(updatedAt, that.updatedAt);
    }

    @Override
    public int hashCode() {
        return Objects.hash(id, validatedAt, updatedAt);
    }
}
</file>

<file path="src/main/java/com/atharv/Event_Ticket_Platform/Domain/Entity/User.java">
package com.atharv.Event_Ticket_Platform.Domain.Entity;

import jakarta.persistence.*;
import lombok.*;
import org.springframework.data.annotation.CreatedDate;
import org.springframework.data.annotation.LastModifiedDate;
import org.springframework.data.jpa.domain.support.AuditingEntityListener;

import java.time.LocalDateTime;
import java.util.ArrayList;
import java.util.List;
import java.util.Objects;
import java.util.UUID;

@EntityListeners(AuditingEntityListener.class)
@Entity
@Table(name="users")
@Getter @Setter @NoArgsConstructor @AllArgsConstructor @Builder
public class User {
    @Id
    private UUID id;

    @Column(name="name",nullable = false)
    private String name;

    @Column(name="email",nullable = false,unique = true)
    private String email;

//    private set<Role> roles;

    // todo : organising event
    @OneToMany(mappedBy = "organiser")
    private List<Event> organisedEvents=new ArrayList<>();

    // todo : attending event
    @ManyToMany(fetch = FetchType.LAZY)
    @JoinTable(
            name="event_attendees",
            joinColumns = @JoinColumn(name="user_id"),
            inverseJoinColumns = @JoinColumn(name="event_id")
    )
    private List<Event> attendingEvents=new ArrayList<>();


    //todo : staffing event
    @ManyToMany
    @JoinTable(
            name="user_staffing_event",
            joinColumns = @JoinColumn(name="user_id"),
            inverseJoinColumns = @JoinColumn(name="event_id")
    )
    private List<Event> staffingEvents=new ArrayList<>();

    @OneToMany(mappedBy = "purchaser")
    private List<Ticket> tickets = new ArrayList<>();


    @CreatedDate
    @Column(name="created_at",nullable=false,updatable = false)
    private LocalDateTime createdAt;

    @LastModifiedDate
    @Column(name="updated_at")
    private LocalDateTime updatedAt;

    @Override
    public boolean equals(Object o) {
        if (o == null || getClass() != o.getClass()) return false;
        User user = (User) o;
        return Objects.equals(id, user.id);
    }

    @Override
    public int hashCode() {
        return Objects.hash(id);
    }
}
</file>

<file path="src/main/java/com/atharv/Event_Ticket_Platform/Domain/Enum/EventStatus.java">
package com.atharv.Event_Ticket_Platform.Domain.Enum;

public enum EventStatus {
    DRAFT,PUBLISHED,CANCELLED,COMPLETED
}
</file>

<file path="src/main/java/com/atharv/Event_Ticket_Platform/Domain/Enum/EventType.java">
package com.atharv.Event_Ticket_Platform.Domain.Enum;

public enum EventType {
    PERFORMANCES,
    EXPERIENCES,
    PARTIES,
    SPORTS,
    CONFERENCES
}
</file>

<file path="src/main/java/com/atharv/Event_Ticket_Platform/Domain/Enum/QrCodeStatus.java">
package com.atharv.Event_Ticket_Platform.Domain.Enum;

public enum QrCodeStatus {
    ACTIVE,EXPIRED
}
</file>

<file path="src/main/java/com/atharv/Event_Ticket_Platform/Domain/Enum/TicketStatus.java">
package com.atharv.Event_Ticket_Platform.Domain.Enum;

public enum TicketStatus {
    PURCHASED, USED, CANCELLED,EXPIRED,INVALID
}
</file>

<file path="src/main/java/com/atharv/Event_Ticket_Platform/Domain/Enum/TicketValidationMethod.java">
package com.atharv.Event_Ticket_Platform.Domain.Enum;

public enum TicketValidationMethod {
    QR,MANUAL
}
</file>

<file path="src/main/java/com/atharv/Event_Ticket_Platform/Domain/Enum/TicketValidationStatus.java">
package com.atharv.Event_Ticket_Platform.Domain.Enum;

public enum TicketValidationStatus {
    VALID,INVALID,EXPIRED,VALIDATED
}
</file>

<file path="src/main/java/com/atharv/Event_Ticket_Platform/Domain/Mapper/EventMapper.java">
package com.atharv.Event_Ticket_Platform.Domain.Mapper;

import com.atharv.Event_Ticket_Platform.Domain.DTO.EventDtos.*;
import com.atharv.Event_Ticket_Platform.Domain.DTO.TicketTypeDto.CreateTicketTypeRequestDto;
import com.atharv.Event_Ticket_Platform.Domain.DTO.TicketTypeDto.ListEventTicketTypeResponseDto;
import com.atharv.Event_Ticket_Platform.Domain.DTO.TicketTypeDto.TicketTypeCreatedResponseDto;
import com.atharv.Event_Ticket_Platform.Domain.DTO.TicketTypeDto.UpdateTicketTypeRequestDto;
import com.atharv.Event_Ticket_Platform.Domain.Requests.CreateEventRequest;
import com.atharv.Event_Ticket_Platform.Domain.Requests.CreateTicketTypeRequest;
import com.atharv.Event_Ticket_Platform.Domain.Entity.Event;
import com.atharv.Event_Ticket_Platform.Domain.Entity.TicketType;
import org.mapstruct.Mapper;
import org.mapstruct.Mapping;

import java.util.List;

@Mapper(componentModel = "spring")
public interface EventMapper {

    List<CreateTicketTypeRequest> fromDtoList(List<CreateTicketTypeRequestDto> dtos);

    CreateTicketTypeRequest fromDto(CreateTicketTypeRequestDto createTicketTypeRequestDto);
    CreateEventRequest fromDto(CreateEventRequestDto createEventRequestDto);
    EventCreatedResponseDto toDto(Event event);
    TicketTypeCreatedResponseDto toDto(TicketType ticketType);
    List<TicketTypeCreatedResponseDto> toDto(List<TicketType> ticketTypes);

    @Mapping(target = "id",ignore = true) // do not map the id from client
    @Mapping(target = "eventStatus",ignore = true) // do not map the eventStatus from client
    @Mapping(target = "organiser",ignore = true) // do not set the organiser from client , it is set from jwt
    // ticketType in CreateEventRequest ->(to)  ticketType in Event class
    @Mapping(target = "attendees", ignore = true)
    @Mapping(target = "staff", ignore = true)
    @Mapping(target = "createdAt", ignore = true)
    @Mapping(target = "updatedAt", ignore = true)
    Event toEvent(CreateEventRequest eventRequest);

    @Mapping(target = "id", ignore = true)
    @Mapping(target = "event", ignore = true)
    @Mapping(target = "ticket", ignore = true)
    @Mapping(target = "createdAt", ignore = true)
    @Mapping(target = "updatedAt", ignore = true)
    TicketType toTicketType(CreateTicketTypeRequest ticketTypeRequest);


    ListEventTicketTypeResponseDto toListEventTicketTypeResponseDto(TicketType ticketType);
    ListEventResponseDto toListEventResponseDto(Event event);

    @Mapping(target = "id" , ignore = true)
    Event fromUpdateEventRequestDto(UpdateEventRequestDto updateEventRequestDto);

    List<TicketType> fromUpdateTicketTypeRequestDto(List<UpdateTicketTypeRequestDto> updateTicketTypeRequestDto);

    UpdatedEventResponseDto toUpdatedEventResponseDto(Event event);
    EventResponseDto toEventResponseDto(Event event);

    PublishEventDto toPublishEventDto(Event event);


}
</file>

<file path="src/main/java/com/atharv/Event_Ticket_Platform/Domain/Mapper/TicketMapper.java">
package com.atharv.Event_Ticket_Platform.Domain.Mapper;

import com.atharv.Event_Ticket_Platform.Domain.DTO.EventDtos.EventDtoForTicketPurchase;
import com.atharv.Event_Ticket_Platform.Domain.DTO.QrCodeDtos.QrCodeDetails;
import com.atharv.Event_Ticket_Platform.Domain.DTO.TicketDtos.TicketPurchasedDetails;
import com.atharv.Event_Ticket_Platform.Domain.DTO.TicketDtos.TicketPurchasedDto;
import com.atharv.Event_Ticket_Platform.Domain.DTO.TicketTypeDto.TicketTypeDetails;
import com.atharv.Event_Ticket_Platform.Domain.DTO.TicketTypeDto.TicketTypeDtoForTicketPurchase;
import com.atharv.Event_Ticket_Platform.Domain.Entity.Event;
import com.atharv.Event_Ticket_Platform.Domain.Entity.QrCode;
import com.atharv.Event_Ticket_Platform.Domain.Entity.Ticket;
import com.atharv.Event_Ticket_Platform.Domain.Entity.TicketType;
import org.mapstruct.Mapper;
import org.mapstruct.Mapping;
import org.springframework.data.domain.Page;

import java.util.List;

@Mapper(componentModel = "spring")
public interface TicketMapper {
    @Mapping(
            target = "event",
            source = "ticketType.event"
    )
    TicketPurchasedDto toTicketPuchasedDto(Ticket ticket);
    EventDtoForTicketPurchase toEventDtoFromTicket(Event event);
    TicketTypeDtoForTicketPurchase toTicketTypeDtoForTicketPurchase(TicketType ticketType);

    @Mapping(target="purchasedAt",source="createdAt")
    TicketPurchasedDetails toDetails(Ticket ticket);

    TicketTypeDetails toDetails(TicketType ticketType);

    QrCodeDetails toDetails(QrCode qrCode);


}
</file>

<file path="src/main/java/com/atharv/Event_Ticket_Platform/Domain/Requests/CreateEventRequest.java">
package com.atharv.Event_Ticket_Platform.Domain.Requests;

import com.atharv.Event_Ticket_Platform.Domain.Enum.EventStatus;
import com.atharv.Event_Ticket_Platform.Domain.Enum.EventType;
import lombok.AllArgsConstructor;
import lombok.Data;
import lombok.NoArgsConstructor;

import java.time.LocalDateTime;
import java.util.ArrayList;
import java.util.List;

@Data
@NoArgsConstructor
@AllArgsConstructor
public class CreateEventRequest {

    private String name;
    private LocalDateTime startTime;
    private LocalDateTime endTime;
    private String venue;
    private EventType eventType;
    private LocalDateTime salesStartDate;
    private LocalDateTime salesEndDate;
    private String description;
    private List<CreateTicketTypeRequest> ticketTypes = new ArrayList<>();


}
</file>

<file path="src/main/java/com/atharv/Event_Ticket_Platform/Domain/Requests/CreateTicketTypeRequest.java">
package com.atharv.Event_Ticket_Platform.Domain.Requests;

import jakarta.persistence.criteria.CriteriaBuilder;
import lombok.AllArgsConstructor;
import lombok.Data;
import lombok.NoArgsConstructor;

@Data
@NoArgsConstructor
@AllArgsConstructor
public class CreateTicketTypeRequest {
    private String name;
    private Double price;
    private  String description;
    private Integer totalAvailable;

}
</file>

<file path="src/main/java/com/atharv/Event_Ticket_Platform/Exceptions/EventTicketExceptions.java">
package com.atharv.Event_Ticket_Platform.Exceptions;

public class EventTicketExceptions extends RuntimeException{
    public EventTicketExceptions() {
    }

    public EventTicketExceptions(String message) {
        super(message);
    }

    public EventTicketExceptions(String message, Throwable cause) {
        super(message, cause);
    }

    public EventTicketExceptions(Throwable cause) {
        super(cause);
    }

    public EventTicketExceptions(String message, Throwable cause, boolean enableSuppression, boolean writableStackTrace) {
        super(message, cause, enableSuppression, writableStackTrace);
    }
}
</file>

<file path="src/main/java/com/atharv/Event_Ticket_Platform/Exceptions/QrCodeNotFoundException.java">
package com.atharv.Event_Ticket_Platform.Exceptions;

public class QrCodeNotFoundException extends EventTicketExceptions{
    public QrCodeNotFoundException() {
        super();
    }

    public QrCodeNotFoundException(String message) {
        super(message);
    }

    public QrCodeNotFoundException(String message, Throwable cause) {
        super(message, cause);
    }

    public QrCodeNotFoundException(Throwable cause) {
        super(cause);
    }

    public QrCodeNotFoundException(String message, Throwable cause, boolean enableSuppression, boolean writableStackTrace) {
        super(message, cause, enableSuppression, writableStackTrace);
    }
}
</file>

<file path="src/main/java/com/atharv/Event_Ticket_Platform/Exceptions/QrCodeNotGeneratedException.java">
package com.atharv.Event_Ticket_Platform.Exceptions;

public class QrCodeNotGeneratedException extends EventTicketExceptions{
    public QrCodeNotGeneratedException() {
        super();
    }

    public QrCodeNotGeneratedException(String message) {
        super(message);
    }

    public QrCodeNotGeneratedException(String message, Throwable cause) {
        super(message, cause);
    }

    public QrCodeNotGeneratedException(Throwable cause) {
        super(cause);
    }

    public QrCodeNotGeneratedException(String message, Throwable cause, boolean enableSuppression, boolean writableStackTrace) {
        super(message, cause, enableSuppression, writableStackTrace);
    }
}
</file>

<file path="src/main/java/com/atharv/Event_Ticket_Platform/Exceptions/ResourceNotFoundException.java">
package com.atharv.Event_Ticket_Platform.Exceptions;

import org.springframework.http.HttpStatus;
import org.springframework.web.bind.annotation.ResponseStatus;

@ResponseStatus(HttpStatus.NOT_FOUND)
public class ResourceNotFoundException extends RuntimeException {

    public ResourceNotFoundException(String message) {
        super(message);
    }
}
</file>

<file path="src/main/java/com/atharv/Event_Ticket_Platform/Exceptions/TicketNotPurchasedException.java">
package com.atharv.Event_Ticket_Platform.Exceptions;

public class TicketNotPurchasedException extends EventTicketExceptions{
    public TicketNotPurchasedException() {
        super();
    }

    public TicketNotPurchasedException(String message) {
        super(message);
    }

    public TicketNotPurchasedException(String message, Throwable cause) {
        super(message, cause);
    }

    public TicketNotPurchasedException(Throwable cause) {
        super(cause);
    }

    public TicketNotPurchasedException(String message, Throwable cause, boolean enableSuppression, boolean writableStackTrace) {
        super(message, cause, enableSuppression, writableStackTrace);
    }
}
</file>

<file path="src/main/java/com/atharv/Event_Ticket_Platform/Exceptions/TicketSoldOutException.java">
package com.atharv.Event_Ticket_Platform.Exceptions;

public class TicketSoldOutException extends EventTicketExceptions{
    public TicketSoldOutException() {
        super();
    }

    public TicketSoldOutException(String message) {
        super(message);
    }

    public TicketSoldOutException(String message, Throwable cause) {
        super(message, cause);
    }

    public TicketSoldOutException(Throwable cause) {
        super(cause);
    }

    public TicketSoldOutException(String message, Throwable cause, boolean enableSuppression, boolean writableStackTrace) {
        super(message, cause, enableSuppression, writableStackTrace);
    }
}
</file>

<file path="src/main/java/com/atharv/Event_Ticket_Platform/Exceptions/UserNotFoundExceptions.java">
package com.atharv.Event_Ticket_Platform.Exceptions;

public class UserNotFoundExceptions extends EventTicketExceptions{
    public UserNotFoundExceptions() {
    }

    public UserNotFoundExceptions(String message) {
        super(message);
    }

    public UserNotFoundExceptions(String message, Throwable cause) {
        super(message, cause);
    }

    public UserNotFoundExceptions(Throwable cause) {
        super(cause);
    }

    public UserNotFoundExceptions(String message, Throwable cause, boolean enableSuppression, boolean writableStackTrace) {
        super(message, cause, enableSuppression, writableStackTrace);
    }
}
</file>

<file path="src/main/java/com/atharv/Event_Ticket_Platform/Filters/StaffValidationFilter.java">
package com.atharv.Event_Ticket_Platform.Filters;

import com.atharv.Event_Ticket_Platform.Domain.Entity.Staff;
import com.atharv.Event_Ticket_Platform.Repository.StaffRepo;
import jakarta.servlet.FilterChain;
import jakarta.servlet.ServletException;
import jakarta.servlet.http.HttpServletRequest;
import jakarta.servlet.http.HttpServletResponse;
import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;
import org.springframework.security.core.Authentication;
import org.springframework.security.core.GrantedAuthority;
import org.springframework.security.core.context.SecurityContextHolder;
import org.springframework.security.oauth2.jwt.Jwt;
import org.springframework.stereotype.Component;
import org.springframework.web.filter.OncePerRequestFilter;

import java.io.IOException;
import java.time.LocalDateTime;
import java.util.Optional;
import java.util.UUID;

import static org.springframework.security.core.context.SecurityContextHolder.*;

/**
 * ‚úÖ Filter to validate staff credentials on each request
 * Checks if staff member's credentials are still valid
 */
@Component
@RequiredArgsConstructor
@Slf4j
public class StaffValidationFilter extends OncePerRequestFilter {

    private final StaffRepo staffRepo;

    @Override
    protected void doFilterInternal(
            HttpServletRequest request,
            HttpServletResponse response,
            FilterChain filterChain
    ) throws ServletException, IOException {

        Authentication authentication = getContext().getAuthentication();

        if (authentication != null &&
                authentication.isAuthenticated() &&
                authentication.getPrincipal() instanceof Jwt jwt) {

            // Check if user has ROLE_STAFF
            boolean isStaff = authentication.getAuthorities().stream()
                    .map(GrantedAuthority::getAuthority)
                    .anyMatch(role -> role.equals("ROLE_STAFF"));

            if (isStaff) {
                UUID staffUserId = UUID.fromString(jwt.getSubject());

                Optional<Staff> staffOpt = staffRepo.findByStaffUserId(staffUserId);

                if (staffOpt.isPresent()) {
                    Staff staff = staffOpt.get();

                    // Update last login time
                    if (staff.getLastLogin() == null ||
                            staff.getLastLogin().isBefore(LocalDateTime.now().minusMinutes(5))) {
                        staff.setLastLogin(LocalDateTime.now());
                        staffRepo.save(staff);
                    }

                    // ‚úÖ Check if credentials are expired
                    if (staff.isExpired()) {
                        log.warn("Staff member {} credentials have expired", staffUserId);
                        response.setStatus(HttpServletResponse.SC_FORBIDDEN);
                        response.setContentType("application/json");
                        response.getWriter().write(
                                "{\"error\": \"Staff credentials expired\", " +
                                        "\"message\": \"Your access credentials have expired. Please contact the event organiser.\"}"
                        );
                        return;
                    }

                    // ‚úÖ Check if account is inactive
                    if (!staff.getIsActive()) {
                        log.warn("Staff member {} account is inactive", staffUserId);
                        response.setStatus(HttpServletResponse.SC_FORBIDDEN);
                        response.setContentType("application/json");
                        response.getWriter().write(
                                "{\"error\": \"Account inactive\", " +
                                        "\"message\": \"Your account has been deactivated. Please contact the event organiser.\"}"
                        );
                        return;
                    }
                }
            }
        }

        filterChain.doFilter(request, response);
    }
}
</file>

<file path="src/main/java/com/atharv/Event_Ticket_Platform/Filters/UserProvisioningFilter.java">
package com.atharv.Event_Ticket_Platform.Filters;

import com.atharv.Event_Ticket_Platform.Domain.Entity.User;
import com.atharv.Event_Ticket_Platform.Repository.UserRepo;
import com.atharv.Event_Ticket_Platform.Service.ServiceImpl.KeycloakRoleService;
import com.atharv.Event_Ticket_Platform.Service.ServiceInterface.UserService;
import jakarta.servlet.FilterChain;
import jakarta.servlet.ServletException;
import jakarta.servlet.http.HttpServletRequest;
import jakarta.servlet.http.HttpServletResponse;
import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;
import org.springframework.security.core.Authentication;
import org.springframework.security.core.context.SecurityContextHolder;
import org.springframework.security.oauth2.jwt.Jwt;
import org.springframework.stereotype.Component;
import org.springframework.web.filter.OncePerRequestFilter;
import java.io.IOException;
import java.security.Security;
import java.util.UUID;
// OncePerRequestFilter is abstract class , we must implement methods of this class

@Component
@RequiredArgsConstructor
@Slf4j  // ‚Üê Add this
public class UserProvisioningFilter extends OncePerRequestFilter {

    private final UserRepo userRepo;
    private final UserService userService;
    private final KeycloakRoleService keycloakRoleService;
    @Override
    protected void doFilterInternal(HttpServletRequest request, HttpServletResponse response, FilterChain filterChain) throws ServletException, IOException {
        log.info("=== UserProvisioningFilter executing for path: {}", request.getRequestURI());
        // doFilterInternal is executed for every authenticated requests (means after the Security Authentication Filter)

        Authentication authentication = SecurityContextHolder.getContext().getAuthentication();
        // authentication obj is stored in SecurityContextHolder

        if(authentication!=null && authentication.isAuthenticated() && authentication.getPrincipal() instanceof Jwt jwt){
            // principal is authenticated user , it contains the identity information(id,username,email)
            // but principal can of diff types depending on authentication method (here authentication method is jwt so principal is of jwt type)
            // getPrincipal() instanceof Jwt jwt checks if principal jwt based identity , if yes it casts it into jwt type
//            UUID keycloakId = UUID.fromString(jwt.getSubject()); // subject is unique identifier of user (primary key)
            // UUID.fromString(string) convert string to UUID obj , as id is stored as UUID in db not as string
            UUID keycloakId = UUID.fromString(jwt.getSubject());
            User user=userService.ensureUserExists(keycloakId,jwt);

            try {
                keycloakRoleService.assignDefaultRole(keycloakId.toString());
            } catch (Exception e) {
                log.warn("Failed to assign default role to user {}: {}", keycloakId, e.getMessage());
            }
            log.info("JWT authenticated - keycloakId: {}", keycloakId);
            request.setAttribute("jwt", jwt);



        }
        filterChain.doFilter(request,response); // request proceeds to further controller,service...
        log.info("=== UserProvisioningFilter completed");
    }
}
</file>

<file path="src/main/java/com/atharv/Event_Ticket_Platform/Repository/EventRepo.java">
package com.atharv.Event_Ticket_Platform.Repository;

import com.atharv.Event_Ticket_Platform.Domain.Entity.Event;
import com.atharv.Event_Ticket_Platform.Domain.Enum.EventStatus;
import org.springframework.data.domain.Page;
import org.springframework.data.domain.Pageable;
import org.springframework.data.jpa.repository.JpaRepository;
import org.springframework.stereotype.Repository;

import java.util.Optional;
import java.util.UUID;

@Repository
public interface EventRepo extends JpaRepository<Event, UUID> {
    Page<Event> findByOrganiserId(UUID organiserId ,Pageable pageable);
    Optional<Event> findByIdAndOrganiser_id(UUID eventId, UUID organiserId);

    Page<Event> findByEventStatus(EventStatus eventStatus, Pageable pageable);

    Page<Event> findByEventStatusAndNameContainingIgnoreCase(
            EventStatus eventStatus,
            String name,
            Pageable pageable
    );

}
</file>

<file path="src/main/java/com/atharv/Event_Ticket_Platform/Repository/QrCodeRepo.java">
package com.atharv.Event_Ticket_Platform.Repository;

import com.atharv.Event_Ticket_Platform.Domain.Entity.QrCode;
import com.atharv.Event_Ticket_Platform.Domain.Enum.QrCodeStatus;
import org.springframework.data.jpa.repository.JpaRepository;
import org.springframework.stereotype.Repository;

import java.util.List;
import java.util.Optional;
import java.util.UUID;

@Repository
public interface QrCodeRepo extends JpaRepository<QrCode, UUID> {
    List<QrCode> findByQrCodeStatusAndTicket_Id(QrCodeStatus status,UUID ticketId);

   QrCode findTopByTicket_IdOrderByGeneratedDateTimeDesc(UUID ticketId);

    boolean existsByPublicCode(String publicCode);

    Optional<QrCode> findByPublicCode(String publicCode);

}
</file>

<file path="src/main/java/com/atharv/Event_Ticket_Platform/Repository/StaffRepo.java">
package com.atharv.Event_Ticket_Platform.Repository;

import com.atharv.Event_Ticket_Platform.Domain.Entity.Staff;
import org.springframework.data.domain.Page;
import org.springframework.data.domain.Pageable;
import org.springframework.data.jpa.repository.JpaRepository;
import org.springframework.data.jpa.repository.Query;
import org.springframework.data.repository.query.Param;

import java.time.LocalDateTime;
import java.util.List;
import java.util.Optional;
import java.util.UUID;

public interface StaffRepo extends JpaRepository<Staff, Long> {

    // ‚úÖ Find all staff for a specific event
    Page<Staff> findByCreatedByOrganiserIdAndEventId(
            UUID organiserId,
            UUID eventId,
            Pageable pageable
    );

    // ‚úÖ Find active staff for a specific event
    Page<Staff> findByCreatedByOrganiserIdAndEventIdAndIsActiveTrue(
            UUID organiserId,
            UUID eventId,
            Pageable pageable
    );

    // ‚úÖ Find valid (active + not expired) staff for an event
    @Query("SELECT s FROM Staff s WHERE s.createdByOrganiserId = :organiserId " +
            "AND s.eventId = :eventId " +
            "AND s.isActive = true " +
            "AND s.validUntil > :now")
    Page<Staff> findValidStaffByEvent(
            @Param("organiserId") UUID organiserId,
            @Param("eventId") UUID eventId,
            @Param("now") LocalDateTime now,
            Pageable pageable
    );

    // Find specific staff by user ID
    Optional<Staff> findByStaffUserId(UUID staffUserId);

    // Find all active staff for an organiser (across all events)
    List<Staff> findByCreatedByOrganiserIdAndIsActiveTrue(UUID organiserId);

    // ‚úÖ Find all staff for an organiser and event
    List<Staff> findByCreatedByOrganiserIdAndEventId(
            UUID organiserId,
            UUID eventId
    );

    // Check if staff exists
    boolean existsByStaffUserId(UUID staffUserId);

    // ‚úÖ Count active staff for an event
    @Query("SELECT COUNT(s) FROM Staff s WHERE s.eventId = :eventId " +
            "AND s.isActive = true " +
            "AND s.validUntil > :now")
    long countActiveStaffByEvent(
            @Param("eventId") UUID eventId,
            @Param("now") LocalDateTime now
    );
}
</file>

<file path="src/main/java/com/atharv/Event_Ticket_Platform/Repository/TicketsRepo.java">
package com.atharv.Event_Ticket_Platform.Repository;

import com.atharv.Event_Ticket_Platform.Domain.Entity.Ticket;
import com.atharv.Event_Ticket_Platform.Domain.Enum.TicketStatus;
import org.springframework.data.domain.Page;
import org.springframework.data.domain.Pageable;
import org.springframework.data.jpa.repository.JpaRepository;
import org.springframework.data.jpa.repository.Query;
import org.springframework.data.repository.query.Param;
import org.springframework.stereotype.Repository;

import java.util.List;
import java.util.UUID;

@Repository
public interface TicketsRepo extends JpaRepository<Ticket, UUID> {

    Page<Ticket> findByPurchaser_Id(UUID userID, Pageable pageable);

    long countByTicketType_Event_Id(UUID eventId);

    @Query("SELECT COUNT(t) FROM Ticket t " +
            "WHERE t.ticketType.event.id = :eventId " +
            "AND t.status = :status")
    long countByTicketType_Event_IdAndStatus(
            @Param("eventId") UUID eventId,
            @Param("status") TicketStatus status
    );

    @Query("SELECT t FROM Ticket t WHERE t.ticketType.event.id = :eventId")
    Page<Ticket> findByEventId(@Param("eventId") UUID eventId, Pageable pageable);

    /**
     * ‚úÖ NEW: Get all tickets for an event (for revenue calculation)
     */
    @Query("SELECT t FROM Ticket t WHERE t.ticketType.event.id = :eventId")
    List<Ticket> findAllByEventId(@Param("eventId") UUID eventId);
}
</file>

<file path="src/main/java/com/atharv/Event_Ticket_Platform/Repository/TicketTypeRepo.java">
package com.atharv.Event_Ticket_Platform.Repository;

import com.atharv.Event_Ticket_Platform.Domain.Entity.TicketType;
import jakarta.persistence.LockModeType;
import org.springframework.data.jpa.repository.JpaRepository;
import org.springframework.data.jpa.repository.Lock;
import org.springframework.data.jpa.repository.Query;
import org.springframework.data.repository.query.Param;
import org.springframework.stereotype.Repository;

import java.util.List;
import java.util.Optional;
import java.util.UUID;


@Repository
public interface TicketTypeRepo extends JpaRepository<TicketType,Integer> {
    @Lock(LockModeType.PESSIMISTIC_WRITE)
    @Query("Select tt from TicketType tt where tt.id = :id")
    Optional<TicketType> findByIdForUpdate(@Param("id") Integer id);

}
</file>

<file path="src/main/java/com/atharv/Event_Ticket_Platform/Repository/TicketValidationRepo.java">
package com.atharv.Event_Ticket_Platform.Repository;

import com.atharv.Event_Ticket_Platform.Domain.Entity.TicketValidation;
import com.atharv.Event_Ticket_Platform.Domain.Enum.TicketValidationStatus;
import org.springframework.data.domain.Page;
import org.springframework.data.domain.Pageable;
import org.springframework.data.jpa.repository.JpaRepository;
import org.springframework.data.jpa.repository.Query;
import org.springframework.data.repository.query.Param;
import org.springframework.stereotype.Repository;

import java.util.UUID;

@Repository
public interface TicketValidationRepo extends JpaRepository<TicketValidation, UUID> {

    // Existing methods
    long countByEvent_IdAndValidationStatus(UUID eventId, TicketValidationStatus status);

    long countByEvent_IdAndValidationStatusAndStaff_StaffUserId(
            UUID eventId,
            TicketValidationStatus status,
            UUID staffId
    );

    long countByEvent_IdAndTicket_TicketType_IdAndValidationStatus(
            UUID eventId,
            Integer ticketTypeId,
            TicketValidationStatus status
    );

    @Query("SELECT tv FROM TicketValidation tv " +
            "WHERE tv.event.id = :eventId " +
            "AND tv.staff.staffUserId = :staffUserId " +
            "ORDER BY tv.validatedAt DESC")
    Page<TicketValidation> findByEvent_IdAndStaff_StaffUserId(
            @Param("eventId") UUID eventId,
            @Param("staffUserId") UUID staffUserId,
            Pageable pageable
    );

    @Query("SELECT tv FROM TicketValidation tv " +
            "WHERE tv.event.id = :eventId " +
            "ORDER BY tv.validatedAt DESC")
    Page<TicketValidation> findByEvent_Id(
            @Param("eventId") UUID eventId,
            Pageable pageable
    );

    /**
     * ‚úÖ NEW: Count validations by staff and ticket type
     */
    @Query("SELECT COUNT(tv) FROM TicketValidation tv " +
            "WHERE tv.staff.staffUserId = :staffUserId " +
            "AND tv.ticket.ticketType.id = :ticketTypeId " +
            "AND tv.validationStatus = :status")
    long countByStaff_StaffUserIdAndTicket_TicketType_IdAndValidationStatus(
            @Param("staffUserId") UUID staffUserId,
            @Param("ticketTypeId") Integer ticketTypeId,
            @Param("status") TicketValidationStatus status
    );

    /**
     * Find all validated attendees for an event
     */
    @Query("SELECT DISTINCT tv FROM TicketValidation tv " +
            "JOIN FETCH tv.ticket t " +
            "JOIN FETCH t.purchaser " +
            "WHERE tv.event.id = :eventId " +
            "AND tv.validationStatus = :status " +
            "ORDER BY tv.validatedAt DESC")
    Page<TicketValidation> findValidatedAttendeesByEvent(
            @Param("eventId") UUID eventId,
            @Param("status") TicketValidationStatus status,
            Pageable pageable
    );



}
</file>

<file path="src/main/java/com/atharv/Event_Ticket_Platform/Repository/UserRepo.java">
package com.atharv.Event_Ticket_Platform.Repository;

import com.atharv.Event_Ticket_Platform.Domain.Entity.User;
import org.springframework.data.jpa.repository.JpaRepository;
import org.springframework.stereotype.Repository;

import java.util.UUID;

@Repository
public interface UserRepo extends JpaRepository<User, UUID> {
}
</file>

<file path="src/main/java/com/atharv/Event_Ticket_Platform/Service/ServiceImpl/AnalyticsService.java">
package com.atharv.Event_Ticket_Platform.Service.ServiceImpl;


import com.atharv.Event_Ticket_Platform.Domain.DTO.AnalyticDtos.*;
import com.atharv.Event_Ticket_Platform.Domain.Entity.*;
import com.atharv.Event_Ticket_Platform.Domain.Enum.EventStatus;
import com.atharv.Event_Ticket_Platform.Domain.Enum.TicketValidationStatus;
import com.atharv.Event_Ticket_Platform.Repository.EventRepo;
import com.atharv.Event_Ticket_Platform.Repository.TicketValidationRepo;
import com.atharv.Event_Ticket_Platform.Repository.TicketsRepo;
import com.atharv.Event_Ticket_Platform.Repository.UserRepo;
import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;
import org.springframework.data.domain.Page;
import org.springframework.data.domain.Pageable;
import org.springframework.stereotype.Service;

import java.util.*;
import java.util.stream.Collectors;

/**
 * üìä Complete Analytics Service
 * Provides comprehensive analytics per ticket type, per event, and across all events
 */
@Service
@RequiredArgsConstructor
@Slf4j
public class AnalyticsService {
    private final EventRepo eventRepo;
    private final TicketsRepo ticketsRepo;
    private final TicketValidationRepo ticketValidationRepo;
    private final UserRepo userRepo;

    /**
     * ‚úÖ Get complete analytics for a specific event
     * Shows ticket sales, revenue, and attendees per ticket type
     */
    public EventAnalyticsDto getEventAnalytics(UUID eventId, UUID organiserId) {
        log.info("Fetching analytics for event: {}", eventId);

        Event event = eventRepo.findById(eventId)
                .orElseThrow(() -> new IllegalStateException("Event not found"));

        // Verify ownership
        if (!event.getOrganiser().getId().equals(organiserId)) {
            throw new IllegalStateException("You don't have permission to view this event");
        }

        // Calculate overall metrics
        long totalTicketsSold = ticketsRepo.countByTicketType_Event_Id(eventId);
        List<Ticket> allTickets = ticketsRepo.findAllByEventId(eventId);
        double totalRevenue = allTickets.stream()
                .mapToDouble(Ticket::getPrice)
                .sum();
        long totalValidated = ticketValidationRepo.countByEvent_IdAndValidationStatus(
                eventId,
                TicketValidationStatus.VALID
        );
        double overallAttendanceRate = totalTicketsSold > 0 ?
                (double) totalValidated / totalTicketsSold * 100 : 0;

        // Calculate per ticket type analytics
        List<TicketTypeAnalyticsDto> ticketTypeAnalytics = event.getTicketTypes().stream()
                .map(ticketType -> calculateTicketTypeAnalytics(ticketType, eventId))
                .collect(Collectors.toList());

        return EventAnalyticsDto.builder()
                .eventId(event.getId())
                .eventName(event.getName())
                .eventStatus(event.getEventStatus().name())
                .eventType(event.getEventType() != null ? event.getEventType().name() : null)
                .venue(event.getVenue())
                .startTime(event.getStartTime())
                .endTime(event.getEndTime())
                .totalTicketsSold(totalTicketsSold)
                .totalRevenue(totalRevenue)
                .totalAttendeesValidated(totalValidated)
                .overallAttendanceRate(overallAttendanceRate)
                .ticketTypeAnalytics(ticketTypeAnalytics)
                .build();
    }

    /**
     * ‚úÖ Calculate analytics for a specific ticket type
     */
    private TicketTypeAnalyticsDto calculateTicketTypeAnalytics(TicketType ticketType, UUID eventId) {
        List<Ticket> soldTickets = ticketType.getTicket();
        long ticketsSold = soldTickets.size();

        double revenue = soldTickets.stream()
                .mapToDouble(Ticket::getPrice)
                .sum();

        long validated = ticketValidationRepo.countByEvent_IdAndTicket_TicketType_IdAndValidationStatus(
                eventId,
                ticketType.getId(),
                TicketValidationStatus.VALID
        );

        double attendanceRate = ticketsSold > 0 ? (double) validated / ticketsSold * 100 : 0;

        int remaining = ticketType.getTotalAvailable() != null ?
                ticketType.getTotalAvailable() : 0;

        return TicketTypeAnalyticsDto.builder()
                .ticketTypeId(ticketType.getId())
                .ticketTypeName(ticketType.getName())
                .price(ticketType.getPrice())
                .totalAvailable(ticketType.getTotalAvailable())
                .ticketsSold(ticketsSold)
                .revenue(revenue)
                .attendeesValidated(validated)
                .attendanceRate(attendanceRate)
                .remainingTickets(remaining)
                .build();
    }

    /**
     * ‚úÖ Get complete analytics across ALL events for an organizer
     * This is the main analytics dashboard
     */
    public OrganiserCompleteAnalyticsDto getCompleteOrganiserAnalytics(UUID organiserId) {
        log.info("Fetching complete analytics for organiser: {}", organiserId);

        User organiser = userRepo.findById(organiserId)
                .orElseThrow(() -> new IllegalStateException("Organiser not found"));

        List<Event> allEvents = organiser.getOrganisedEvents();

        // Count event types
        long publishedCount = allEvents.stream()
                .filter(e -> e.getEventStatus() == EventStatus.PUBLISHED)
                .count();

        long draftCount = allEvents.stream()
                .filter(e -> e.getEventStatus() == EventStatus.DRAFT)
                .count();

        // Calculate totals across all events
        long totalTicketsSold = 0;
        double totalRevenue = 0.0;
        long totalValidated = 0;
        List<Double> attendanceRates = new ArrayList<>();

        List<EventAnalyticsDto> eventAnalyticsList = new ArrayList<>();

        for (Event event : allEvents) {
            EventAnalyticsDto eventAnalytics = getEventAnalytics(event.getId(), organiserId);
            eventAnalyticsList.add(eventAnalytics);

            totalTicketsSold += eventAnalytics.getTotalTicketsSold();
            totalRevenue += eventAnalytics.getTotalRevenue();
            totalValidated += eventAnalytics.getTotalAttendeesValidated();

            if (eventAnalytics.getTotalTicketsSold() > 0) {
                attendanceRates.add(eventAnalytics.getOverallAttendanceRate());
            }
        }

        double averageAttendanceRate = attendanceRates.isEmpty() ? 0 :
                attendanceRates.stream()
                        .mapToDouble(Double::doubleValue)
                        .average()
                        .orElse(0.0);

        // Find top performers
        EventAnalyticsDto mostRevenueEvent = eventAnalyticsList.stream()
                .max(Comparator.comparing(EventAnalyticsDto::getTotalRevenue))
                .orElse(null);

        EventAnalyticsDto mostTicketsSoldEvent = eventAnalyticsList.stream()
                .max(Comparator.comparing(EventAnalyticsDto::getTotalTicketsSold))
                .orElse(null);

        EventAnalyticsDto bestAttendanceRateEvent = eventAnalyticsList.stream()
                .filter(e -> e.getTotalTicketsSold() > 0)
                .max(Comparator.comparing(EventAnalyticsDto::getOverallAttendanceRate))
                .orElse(null);

        return OrganiserCompleteAnalyticsDto.builder()
                .organiserId(organiserId)
                .organiserName(organiser.getName())
                .organiserEmail(organiser.getEmail())
                .totalEvents(allEvents.size())
                .publishedEvents((int) publishedCount)
                .draftEvents((int) draftCount)
                .totalTicketsSold(totalTicketsSold)
                .totalRevenue(totalRevenue)
                .totalAttendeesValidated(totalValidated)
                .averageAttendanceRate(averageAttendanceRate)
                .eventAnalytics(eventAnalyticsList)
                .mostRevenueEvent(mostRevenueEvent)
                .mostTicketsSoldEvent(mostTicketsSoldEvent)
                .bestAttendanceRateEvent(bestAttendanceRateEvent)
                .build();
    }

    /**
     * ‚úÖ Get analytics for just published events
     * Useful for seeing active/live events only
     */
    public OrganiserCompleteAnalyticsDto getPublishedEventsAnalytics(UUID organiserId) {
        log.info("Fetching published events analytics for organiser: {}", organiserId);

        User organiser = userRepo.findById(organiserId)
                .orElseThrow(() -> new IllegalStateException("Organiser not found"));

        List<Event> publishedEvents = organiser.getOrganisedEvents().stream()
                .filter(e -> e.getEventStatus() == EventStatus.PUBLISHED)
                .collect(Collectors.toList());

        // Use same logic as complete analytics but only for published events
        return calculateAnalyticsForEventList(organiser, publishedEvents);
    }

    /**
     * Helper method to calculate analytics for a list of events
     */
    private OrganiserCompleteAnalyticsDto calculateAnalyticsForEventList(
            User organiser,
            List<Event> events
    ) {
        long totalTicketsSold = 0;
        double totalRevenue = 0.0;
        long totalValidated = 0;
        List<Double> attendanceRates = new ArrayList<>();

        List<EventAnalyticsDto> eventAnalyticsList = new ArrayList<>();

        for (Event event : events) {
            EventAnalyticsDto eventAnalytics = getEventAnalytics(event.getId(), organiser.getId());
            eventAnalyticsList.add(eventAnalytics);

            totalTicketsSold += eventAnalytics.getTotalTicketsSold();
            totalRevenue += eventAnalytics.getTotalRevenue();
            totalValidated += eventAnalytics.getTotalAttendeesValidated();

            if (eventAnalytics.getTotalTicketsSold() > 0) {
                attendanceRates.add(eventAnalytics.getOverallAttendanceRate());
            }
        }

        double averageAttendanceRate = attendanceRates.isEmpty() ? 0 :
                attendanceRates.stream()
                        .mapToDouble(Double::doubleValue)
                        .average()
                        .orElse(0.0);

        EventAnalyticsDto mostRevenueEvent = eventAnalyticsList.stream()
                .max(Comparator.comparing(EventAnalyticsDto::getTotalRevenue))
                .orElse(null);

        EventAnalyticsDto mostTicketsSoldEvent = eventAnalyticsList.stream()
                .max(Comparator.comparing(EventAnalyticsDto::getTotalTicketsSold))
                .orElse(null);

        EventAnalyticsDto bestAttendanceRateEvent = eventAnalyticsList.stream()
                .filter(e -> e.getTotalTicketsSold() > 0)
                .max(Comparator.comparing(EventAnalyticsDto::getOverallAttendanceRate))
                .orElse(null);

        long publishedCount = events.stream()
                .filter(e -> e.getEventStatus() == EventStatus.PUBLISHED)
                .count();

        return OrganiserCompleteAnalyticsDto.builder()
                .organiserId(organiser.getId())
                .organiserName(organiser.getName())
                .organiserEmail(organiser.getEmail())
                .totalEvents(events.size())
                .publishedEvents((int) publishedCount)
                .draftEvents(events.size() - (int) publishedCount)
                .totalTicketsSold(totalTicketsSold)
                .totalRevenue(totalRevenue)
                .totalAttendeesValidated(totalValidated)
                .averageAttendanceRate(averageAttendanceRate)
                .eventAnalytics(eventAnalyticsList)
                .mostRevenueEvent(mostRevenueEvent)
                .mostTicketsSoldEvent(mostTicketsSoldEvent)
                .bestAttendanceRateEvent(bestAttendanceRateEvent)
                .build();
    }

    /**
     * üÜï Get ticket type performance across all events
     * Shows which ticket type names perform best overall
     */
    public List<TicketTypePerformanceDto> getTicketTypePerformanceAcrossEvents(UUID organiserId) {
        log.info("Fetching ticket type performance for organiser: {}", organiserId);

        User organiser = userRepo.findById(organiserId)
                .orElseThrow(() -> new IllegalStateException("Organiser not found"));

        // Group all ticket types by name
        Map<String, List<TicketType>> ticketTypesByName = new HashMap<>();

        for (Event event : organiser.getOrganisedEvents()) {
            for (TicketType ticketType : event.getTicketTypes()) {
                String name = ticketType.getName();
                ticketTypesByName.computeIfAbsent(name, k -> new ArrayList<>()).add(ticketType);
            }
        }

        // Calculate performance for each ticket type name
        return ticketTypesByName.entrySet().stream()
                .map(entry -> {
                    String typeName = entry.getKey();
                    List<TicketType> types = entry.getValue();

                    long totalSold = types.stream()
                            .flatMap(tt -> tt.getTicket().stream())
                            .count();

                    double totalRevenue = types.stream()
                            .flatMap(tt -> tt.getTicket().stream())
                            .mapToDouble(Ticket::getPrice)
                            .sum();

                    long totalValidated = 0;
                    for (TicketType tt : types) {
                        totalValidated += ticketValidationRepo
                                .countByEvent_IdAndTicket_TicketType_IdAndValidationStatus(
                                        tt.getEvent().getId(),
                                        tt.getId(),
                                        TicketValidationStatus.VALID
                                );
                    }

                    double averagePrice = totalSold > 0 ? totalRevenue / totalSold : 0;

                    return TicketTypePerformanceDto.builder()
                            .ticketTypeName(typeName)
                            .totalSold(totalSold)
                            .totalRevenue(totalRevenue)
                            .totalValidated(totalValidated)
                            .averagePrice(averagePrice)
                            .numberOfEvents(types.size())
                            .build();
                })
                .sorted(Comparator.comparing(TicketTypePerformanceDto::getTotalRevenue).reversed())
                .collect(Collectors.toList());
    }

    /**
     * üÜï Get comparison between events
     * Useful for side-by-side comparison
     */
    public Map<String, Object> compareEvents(UUID organiserId, List<UUID> eventIds) {
        log.info("Comparing {} events for organiser {}", eventIds.size(), organiserId);

        List<EventAnalyticsDto> eventComparisons = eventIds.stream()
                .map(eventId -> getEventAnalytics(eventId, organiserId))
                .collect(Collectors.toList());

        return Map.of(
                "events", eventComparisons,
                "comparisonCount", eventIds.size(),
                "organiserId", organiserId
        );
    }


    public Page<Map<String, Object>> getValidatedAttendees(
            UUID eventId,
            UUID organiserId,
            Pageable pageable
    ) {
        log.info("Fetching validated attendees for event: {}", eventId);

        // Verify event exists and belongs to organiser
        Event event = eventRepo.findById(eventId)
                .orElseThrow(() -> new IllegalStateException("Event not found"));

        if (!event.getOrganiser().getId().equals(organiserId)) {
            throw new IllegalStateException("You don't have permission to view this event");
        }

        // Get validated tickets
        Page<TicketValidation> validations = ticketValidationRepo
                .findValidatedAttendeesByEvent(
                        eventId,
                        TicketValidationStatus.VALID,
                        pageable
                );

        // Map to response
        return validations.map(validation -> {
            Ticket ticket = validation.getTicket();
            User attendee = ticket.getPurchaser();

            return Map.of(
                    "attendeeId", attendee.getId(),
                    "attendeeName", attendee.getName(),
                    "attendeeEmail", attendee.getEmail(),
                    "ticketId", ticket.getId(),
                    "ticketType", ticket.getTicketType().getName(),
                    "ticketPrice", ticket.getPrice(),
                    "validatedAt", validation.getValidatedAt(),
                    "validatedBy", validation.getStaff().getUsername()
            );
        });
    }

    private ValidatedAttendeeResponse mapToDto(TicketValidation tv) {
        Ticket ticket = tv.getTicket();
        User user = ticket.getPurchaser();

        return ValidatedAttendeeResponse.builder()
                .validationId(tv.getId())
                .validatedAt(tv.getValidatedAt())
                .validationMethod(tv.getValidationMethod().name())
                .attendeeId(user.getId())
                .attendeeName(user.getName())
                .attendeeEmail(user.getEmail())
                .ticketId(ticket.getId())
                .ticketType(ticket.getTicketType().getName())
                .ticketPrice(ticket.getPrice())
                .build();
    }
}
</file>

<file path="src/main/java/com/atharv/Event_Ticket_Platform/Service/ServiceImpl/EventServiceImpl.java">
package com.atharv.Event_Ticket_Platform.Service.ServiceImpl;
import com.atharv.Event_Ticket_Platform.Domain.DTO.EventDtos.UpdateEventRequestDto;
import com.atharv.Event_Ticket_Platform.Domain.DTO.TicketTypeDto.UpdateTicketTypeRequestDto;
import com.atharv.Event_Ticket_Platform.Domain.Entity.TicketType;
import com.atharv.Event_Ticket_Platform.Domain.Requests.CreateEventRequest;
import com.atharv.Event_Ticket_Platform.Domain.Entity.Event;
import com.atharv.Event_Ticket_Platform.Domain.Entity.User;
import com.atharv.Event_Ticket_Platform.Domain.Enum.EventStatus;
import com.atharv.Event_Ticket_Platform.Domain.Mapper.EventMapper;
import com.atharv.Event_Ticket_Platform.Exceptions.ResourceNotFoundException;
import com.atharv.Event_Ticket_Platform.Repository.EventRepo;
import com.atharv.Event_Ticket_Platform.Repository.TicketTypeRepo;
import com.atharv.Event_Ticket_Platform.Repository.UserRepo;
import com.atharv.Event_Ticket_Platform.Service.ServiceInterface.EventService;
import jakarta.transaction.Transactional;
import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;
import org.springframework.data.domain.Page;
import org.springframework.data.domain.Pageable;
import org.springframework.security.access.AccessDeniedException;
import org.springframework.security.oauth2.jwt.Jwt;
import org.springframework.stereotype.Service;

import java.util.Optional;
import java.util.UUID;

@Service
@RequiredArgsConstructor
@Slf4j
public class EventServiceImpl implements EventService {
    private final UserRepo userRepo;
    private final EventRepo eventRepo;
    private final TicketTypeRepo ticketTypeRepo;
    private final EventMapper eventMapper;
    private final UserServiceImpl userService;

    @Override
    @Transactional
    public Event createEvent(UUID organiserId, CreateEventRequest eventRequest,Jwt jwt) {

        User organiser = userService.ensureUserExists(organiserId,jwt);

        Event event = eventMapper.toEvent(eventRequest);

        event.setOrganiser(organiser);
        if(event.getSalesStartDate()!=null && event.getSalesEndDate()!=null && !event.getTicketTypes().isEmpty() && event.getName()!=null && event.getDescription()!=null && event.getStartTime()!=null && event.getEndTime()!=null)
            event.setEventStatus(EventStatus.PUBLISHED);
        else event.setEventStatus(EventStatus.DRAFT);
        event.getTicketTypes().
                forEach(ticketType -> ticketType.setEvent(event));
        Event savedEvent = eventRepo.save(event);
        log.info("Event SAVED successfully - ID: {}", savedEvent.getId());
        return savedEvent;

    }



    @Override
    public Page<Event> listEventForOrganiser(UUID organiserId, Pageable pageable) {
        return eventRepo.findByOrganiserId(organiserId,pageable);
    }

    @Override
    @Transactional  // ‚úÖ ADD THIS - Very Important!
    public Event updateEvent(UUID organiserId, UUID eventId, UpdateEventRequestDto updateEventRequestDto) {
        log.info("Updating event - ID: {}, Organiser: {}", eventId, organiserId);

        // 1. Fetch existing event
        Event existingEvent = eventRepo.findByIdAndOrganiser_id(eventId, organiserId)
                .orElseThrow(() -> new ResourceNotFoundException("Event not found or you don't have permission"));

        // 2. Update basic event fields
        if (updateEventRequestDto.getName() != null) {
            existingEvent.setName(updateEventRequestDto.getName());
        }
        if (updateEventRequestDto.getDescription() != null) {
            existingEvent.setDescription(updateEventRequestDto.getDescription());
        }
        if (updateEventRequestDto.getStartTime() != null) {
            existingEvent.setStartTime(updateEventRequestDto.getStartTime());
        }
        if (updateEventRequestDto.getEndTime() != null) {
            existingEvent.setEndTime(updateEventRequestDto.getEndTime());
        }
        if (updateEventRequestDto.getVenue() != null) {
            existingEvent.setVenue(updateEventRequestDto.getVenue());
        }
        if (updateEventRequestDto.getSalesStartDate() != null) {
            existingEvent.setSalesStartDate(updateEventRequestDto.getSalesStartDate());
        }
        if (updateEventRequestDto.getSalesEndDate() != null) {
            existingEvent.setSalesEndDate(updateEventRequestDto.getSalesEndDate());
        }
        if (updateEventRequestDto.getEventType() != null) {
            existingEvent.setEventType(updateEventRequestDto.getEventType());
        }

        // 3. Update ticket types
        if (updateEventRequestDto.getTicketTypes() != null && !updateEventRequestDto.getTicketTypes().isEmpty()) {
            for (UpdateTicketTypeRequestDto ticketDto : updateEventRequestDto.getTicketTypes()) {
                if (ticketDto.getId() != null) {
                    // Update existing ticket type
                    TicketType existingTicketType = ticketTypeRepo.findById(ticketDto.getId())
                            .orElseThrow(() -> new ResourceNotFoundException("TicketType with ID " + ticketDto.getId() + " not found"));

                    // Verify this ticket type belongs to this event
                    if (!existingTicketType.getEvent().getId().equals(eventId)) {
                        throw new IllegalArgumentException("TicketType " + ticketDto.getId() + " does not belong to this event");
                    }

                    // Update ticket type fields
                    if (ticketDto.getName() != null) {
                        existingTicketType.setName(ticketDto.getName());
                    }
                    if (ticketDto.getPrice() != null) {
                        existingTicketType.setPrice(ticketDto.getPrice());
                    }
                    if (ticketDto.getDescription() != null) {
                        existingTicketType.setDescription(ticketDto.getDescription());
                    }
                    if (ticketDto.getTotalAvailable() != null) {
                        existingTicketType.setTotalAvailable(ticketDto.getTotalAvailable());
                    }

                    log.info("Updated ticket type ID: {}", ticketDto.getId());
                } else {
                    // Create new ticket type (if ID is null, it's a new ticket type)
                    TicketType newTicketType = TicketType.builder()
                            .name(ticketDto.getName())
                            .price(ticketDto.getPrice())
                            .description(ticketDto.getDescription())
                            .totalAvailable(ticketDto.getTotalAvailable())
                            .event(existingEvent)
                            .build();

                    existingEvent.getTicketTypes().add(newTicketType);
                    log.info("Created new ticket type: {}", ticketDto.getName());
                }
            }
        }

        // 4. Update event status based on completeness
        updateEventStatus(existingEvent);

        // 5. Save and return updated event
        Event updatedEvent = eventRepo.save(existingEvent);  // ‚úÖ THIS WAS MISSING!
        log.info("Event UPDATED successfully - ID: {}", updatedEvent.getId());

        return updatedEvent;
    }

    // Helper method to update event status
    private void updateEventStatus(Event event) {
        if (event.getSalesStartDate() != null &&
                event.getSalesEndDate() != null &&
                !event.getTicketTypes().isEmpty() &&
                event.getName() != null &&
                event.getDescription() != null &&
                event.getStartTime() != null &&
                event.getEndTime() != null && event.getEventStatus() !=null) {
            event.setEventStatus(EventStatus.PUBLISHED);
        } else {
            event.setEventStatus(EventStatus.DRAFT);
        }
    }

    @Override
    public Event getEvent(UUID eventId, UUID organiserId) {
        Event event = eventRepo.findById(eventId)
                .orElseThrow(() ->
                        new ResourceNotFoundException("Event not found")
                );

        if (!event.getOrganiser().getId().equals(organiserId)) {
            throw new AccessDeniedException("You are not allowed to access this event");
        }
        return event;
    }

    @Override
    public void deleteEvent(UUID eventId,UUID organiserId) {
        Event event = eventRepo.findByIdAndOrganiser_id(eventId,organiserId)
                .orElseThrow(() ->
                        new ResourceNotFoundException("Event not found")
                );

        eventRepo.delete(event);
    }

    @Override
    @Transactional
    public void deleteTicketType(UUID organiserId, UUID eventId, Integer ticketTypeId) {
        log.info("Deleting ticket type - ID: {}, Event: {}, Organiser: {}", ticketTypeId, eventId, organiserId);

        // 1. Verify event ownership
        Event event = eventRepo.findByIdAndOrganiser_id(eventId, organiserId)
                .orElseThrow(() -> new ResourceNotFoundException("Event not found or you don't have permission"));

        // 2. Find ticket type
        TicketType ticketType = ticketTypeRepo.findById(ticketTypeId)
                .orElseThrow(() -> new ResourceNotFoundException("TicketType not found"));

        // 3. Verify ticket type belongs to this event
        if (!ticketType.getEvent().getId().equals(eventId)) {
            throw new IllegalArgumentException("TicketType does not belong to this event");
        }

        // 4. Check if there are tickets sold (optional - prevent deletion if tickets exist)
        if (ticketType.getTicket() != null && !ticketType.getTicket().isEmpty()) {
            throw new IllegalStateException("Cannot delete ticket type with existing tickets sold");
        }

        // 5. Delete ticket type
        ticketTypeRepo.delete(ticketType);
        log.info("TicketType deleted successfully - ID: {}", ticketTypeId);
    }


    @Override
    public Page<Event> listPublishedEvents(Pageable pageable) {
        return eventRepo.findByEventStatus(EventStatus.PUBLISHED, pageable);
    }

    @Override
    public Page<Event> searchPublishedEvents(String searchTerm, Pageable pageable) {
        return eventRepo.findByEventStatusAndNameContainingIgnoreCase(EventStatus.PUBLISHED,searchTerm, pageable);
    }

    @Override
    public Optional<Event> getPublishedEventById(UUID eventId) {
        try {
            return eventRepo.findById(eventId)
                    .filter(event -> event.getEventStatus() == EventStatus.PUBLISHED);
        } catch (IllegalArgumentException e) {
            return Optional.empty();
        }
    }
}
</file>

<file path="src/main/java/com/atharv/Event_Ticket_Platform/Service/ServiceImpl/KeycloakRoleService.java">
package com.atharv.Event_Ticket_Platform.Service.ServiceImpl;

import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;
import org.keycloak.admin.client.Keycloak;
import org.keycloak.admin.client.resource.RealmResource;
import org.keycloak.admin.client.resource.UserResource;
import org.keycloak.admin.client.resource.UsersResource;
import org.keycloak.representations.idm.RoleRepresentation;
import org.keycloak.representations.idm.UserRepresentation;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.stereotype.Service;

import java.util.Collections;
import java.util.List;
import java.util.UUID;
import java.util.stream.Collectors;

@Service
@RequiredArgsConstructor
@Slf4j
public class KeycloakRoleService {

    private final Keycloak keycloak;

    @Value("${keycloak.admin.realm}")
    private String realm;

    /**
     * Get the RealmResource for the configured realm
     */
    private RealmResource getRealmResource() {
        return keycloak.realm(realm);
    }

    /**
     * Get UserResource for a specific user
     */
    private UserResource getUserResource(String userId) {
        return getRealmResource().users().get(userId);
    }

    /**
     * Assign a realm role to a user
     */
    public void assignRole(String userId, String roleName) {
        log.info("Assigning role {} to user {} in Keycloak", roleName, userId);

        try {
            UserResource userResource = getUserResource(userId);

            // Get the role from realm
            RoleRepresentation role = getRealmResource()
                    .roles()
                    .get(roleName)
                    .toRepresentation();

            // Assign role to user
            userResource.roles().realmLevel().add(Collections.singletonList(role));

            log.info("Successfully assigned role {} to user {}", roleName, userId);
        } catch (Exception e) {
            log.error("Failed to assign role {} to user {}: {}", roleName, userId, e.getMessage());
            throw new RuntimeException("Failed to assign role in Keycloak", e);
        }
    }

    /**
     * Remove a realm role from a user
     */
    public void removeRole(String userId, String roleName) {
        log.info("Removing role {} from user {} in Keycloak", roleName, userId);

        try {
            UserResource userResource = getUserResource(userId);

            RoleRepresentation role = getRealmResource()
                    .roles()
                    .get(roleName)
                    .toRepresentation();

            userResource.roles().realmLevel().remove(Collections.singletonList(role));

            log.info("Successfully removed role {} from user {}", roleName, userId);
        } catch (Exception e) {
            log.error("Failed to remove role {} from user {}: {}", roleName, userId, e.getMessage());
            throw new RuntimeException("Failed to remove role in Keycloak", e);
        }
    }

    /**
     * Check if user has a specific role
     */
    public boolean hasRole(String userId, String roleName) {
        try {
            UserResource userResource = getUserResource(userId);

            List<RoleRepresentation> roles = userResource.roles().realmLevel().listAll();

            return roles.stream()
                    .anyMatch(role -> role.getName().equals(roleName));
        } catch (Exception e) {
            log.error("Failed to check role for user {}: {}", userId, e.getMessage());
            return false;
        }
    }

    /**
     * Get all roles for a user
     */
    public List<String> getUserRoles(String userId) {
        try {
            UserResource userResource = getUserResource(userId);

            return userResource.roles().realmLevel().listAll().stream()
                    .map(RoleRepresentation::getName)
                    .collect(Collectors.toList());
        } catch (Exception e) {
            log.error("Failed to get roles for user {}: {}", userId, e.getMessage());
            return Collections.emptyList();
        }
    }

    /**
     * Promote user to ROLE_ORGANISER
     */
    public void promoteToOrganiser(String userId) {
        if (!hasRole(userId, "ROLE_ORGANISER")) {
            assignRole(userId, "ROLE_ORGANISER");
        } else {
            log.info("User {} already has ROLE_ORGANISER", userId);
        }
    }

    /**
     * Assign default ROLE_ATTENDEE to new users
     */
    public void assignDefaultRole(String userId) {
        if (!hasRole(userId, "ROLE_ATTENDEE")) {
            assignRole(userId, "ROLE_ATTENDEE");
        } else {
            log.debug("User {} already has ROLE_ATTENDEE", userId);
        }
    }
}
</file>

<file path="src/main/java/com/atharv/Event_Ticket_Platform/Service/ServiceImpl/KeycloakUserService.java">
package com.atharv.Event_Ticket_Platform.Service.ServiceImpl;

import com.atharv.Event_Ticket_Platform.Domain.DTO.StaffDtos.StaffCredentialWithPasswordDto;
import com.atharv.Event_Ticket_Platform.Domain.Entity.Staff;
import com.atharv.Event_Ticket_Platform.Repository.StaffRepo;
import jakarta.transaction.Transactional;
import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;
import org.keycloak.admin.client.Keycloak;
import org.keycloak.admin.client.resource.RealmResource;
import org.keycloak.admin.client.resource.UsersResource;
import org.keycloak.representations.idm.CredentialRepresentation;
import org.keycloak.representations.idm.UserRepresentation;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.stereotype.Service;

import jakarta.ws.rs.core.Response;
import java.time.LocalDateTime;
import java.util.*;

@Service
@RequiredArgsConstructor
@Slf4j
public class KeycloakUserService {

    private final Keycloak keycloak;
    private final KeycloakRoleService keycloakRoleService;
    private final StaffRepo staffRepo;

    @Value("${keycloak.admin.realm}")
    private String realm;

    /**
     * ‚úÖ Generate staff accounts for a specific event with validity period
     */
    @Transactional
    public List<StaffCredentialWithPasswordDto> createStaffAccounts(
            UUID organiserId,
            UUID eventId,
            int numberOfStaff,
            int validityHours
    ) {
        log.info("Organiser {} requesting {} staff accounts for event {} with {} hours validity",
                organiserId, numberOfStaff, eventId, validityHours);

        if (numberOfStaff <= 0 || numberOfStaff > 100) {
            throw new IllegalArgumentException("Number of staff must be between 1 and 100");
        }

        if (validityHours <= 0 || validityHours > 8760) { // Max 1 year
            throw new IllegalArgumentException("Validity hours must be between 1 and 8760 (1 year)");
        }

        LocalDateTime validFrom = LocalDateTime.now();
        LocalDateTime validUntil = validFrom.plusHours(validityHours);

        List<StaffCredentialWithPasswordDto> staffCredentials = new ArrayList<>();
        RealmResource realmResource = keycloak.realm(realm);
        UsersResource usersResource = realmResource.users();

        for (int i = 0; i < numberOfStaff; i++) {
            String username = generateUniqueUsername();
            String password = generateSecurePassword();
            String email = username + "@staff.eventplatform.com";

            try {
                // Create user representation
                UserRepresentation user = new UserRepresentation();
                user.setEnabled(true);
                user.setUsername(username);
                user.setEmail(email);
                user.setFirstName("Staff");
                user.setLastName(username);
                user.setEmailVerified(true);

                // Set password
                CredentialRepresentation credential = new CredentialRepresentation();
                credential.setType(CredentialRepresentation.PASSWORD);
                credential.setValue(password);
                credential.setTemporary(false);
                user.setCredentials(Collections.singletonList(credential));

                // Create user in Keycloak
                Response response = usersResource.create(user);

                if (response.getStatus() == 201) {
                    String locationHeader = response.getHeaderString("Location");
                    String userId = locationHeader.substring(locationHeader.lastIndexOf('/') + 1);

                    // Assign ROLE_STAFF
                    keycloakRoleService.assignRole(userId, "ROLE_STAFF");

                    // ‚úÖ Store credentials in database with validity period
                    Staff staffCred = Staff.builder()
                            .staffUserId(UUID.fromString(userId))
                            .eventId(eventId) // ‚úÖ Link to specific event
                            .username(username)
                            .email(email)
                            .createdByOrganiserId(organiserId)
                            .isActive(true)
                            .validFrom(validFrom) // ‚úÖ Validity period
                            .validUntil(validUntil) // ‚úÖ Expiration time
                            .build();

                    staffRepo.save(staffCred);

                    // Return credentials (password only shown once)
                    staffCredentials.add(StaffCredentialWithPasswordDto.builder()
                            .staffUserId(UUID.fromString(userId))
                            .username(username)
                            .password(password)
                            .email(email)
                            .validFrom(validFrom)
                            .validUntil(validUntil)
                            .build()
                    );

                    log.info("Created staff account: {} for event: {} by organiser: {}",
                            username, eventId, organiserId);
                } else {
                    log.error("Failed to create staff account. Status: {}", response.getStatus());
                }

                response.close();

            } catch (Exception e) {
                log.error("Error creating staff account: {}", e.getMessage(), e);
            }
        }

        return staffCredentials;
    }

    /**
     * ‚úÖ Delete staff user from Keycloak and deactivate in database
     */
    @Transactional
    public void deleteStaffUser(UUID organiserId, UUID eventId, String userId) {
        log.info("Organiser {} deleting staff user {} from event {}",
                organiserId, userId, eventId);

        // Verify ownership and event association
        Staff staff = staffRepo.findByStaffUserId(UUID.fromString(userId))
                .orElseThrow(() -> new RuntimeException("Staff user not found"));

        if (!staff.getCreatedByOrganiserId().equals(organiserId)) {
            throw new RuntimeException("You don't have permission to delete this staff");
        }

        if (!staff.getEventId().equals(eventId)) {
            throw new RuntimeException("This staff member is not assigned to this event");
        }

        try {
            // Delete from Keycloak
            keycloak.realm(realm).users().delete(userId);

            // Deactivate in database (soft delete)
            staff.setIsActive(false);
            staffRepo.save(staff);

            log.info("Successfully deleted and deactivated staff user {}", userId);
        } catch (Exception e) {
            log.error("Failed to delete staff user {}: {}", userId, e.getMessage());
            throw new RuntimeException("Failed to delete staff user from Keycloak", e);
        }
    }

    /**
     * ‚úÖ Reset staff user password
     */
    @Transactional
    public String resetPassword(UUID organiserId, UUID eventId, String userId) {
        log.info("Organiser {} resetting password for staff user {} in event {}",
                organiserId, userId, eventId);

        // Verify ownership
        Staff staff = staffRepo.findByStaffUserId(UUID.fromString(userId))
                .orElseThrow(() -> new RuntimeException("Staff user not found"));

        if (!staff.getCreatedByOrganiserId().equals(organiserId)) {
            throw new RuntimeException("You don't have permission to reset this staff's password");
        }

        if (!staff.getEventId().equals(eventId)) {
            throw new RuntimeException("This staff member is not assigned to this event");
        }

        try {
            String newPassword = generateSecurePassword();

            CredentialRepresentation credential = new CredentialRepresentation();
            credential.setType(CredentialRepresentation.PASSWORD);
            credential.setValue(newPassword);
            credential.setTemporary(false);

            keycloak.realm(realm).users().get(userId).resetPassword(credential);

            log.info("Successfully reset password for staff user {}", userId);
            return newPassword;

        } catch (Exception e) {
            log.error("Failed to reset password for staff user {}: {}", userId, e.getMessage());
            throw new RuntimeException("Failed to reset password in Keycloak", e);
        }
    }

    /**
     * ‚úÖ Extend validity period for a staff member
     */
    @Transactional
    public Staff extendValidity(UUID organiserId, UUID eventId, String userId, int additionalHours) {
        log.info("Organiser {} extending validity for staff {} by {} hours",
                organiserId, userId, additionalHours);

        Staff staff = staffRepo.findByStaffUserId(UUID.fromString(userId))
                .orElseThrow(() -> new RuntimeException("Staff user not found"));

        if (!staff.getCreatedByOrganiserId().equals(organiserId)) {
            throw new RuntimeException("You don't have permission to modify this staff");
        }

        if (!staff.getEventId().equals(eventId)) {
            throw new RuntimeException("This staff member is not assigned to this event");
        }

        staff.setValidUntil(staff.getValidUntil().plusHours(additionalHours));
        return staffRepo.save(staff);
    }

    private String generateUniqueUsername() {
        String prefix = "staff";
        String randomPart = UUID.randomUUID().toString().substring(0, 8);
        return prefix + "_" + randomPart;
    }

    private String generateSecurePassword() {
        String chars = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789!@#$%";
        Random random = new Random();
        StringBuilder password = new StringBuilder();

        for (int i = 0; i < 12; i++) {
            password.append(chars.charAt(random.nextInt(chars.length())));
        }

        return password.toString();
    }
}
</file>

<file path="src/main/java/com/atharv/Event_Ticket_Platform/Service/ServiceImpl/OrganiserDashboardService.java">
package com.atharv.Event_Ticket_Platform.Service.ServiceImpl;

import com.atharv.Event_Ticket_Platform.Domain.Entity.*;
import com.atharv.Event_Ticket_Platform.Domain.Enum.EventStatus;
import com.atharv.Event_Ticket_Platform.Repository.*;
import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;
import org.springframework.stereotype.Service;

import java.time.LocalDateTime;
import java.util.*;
import java.util.stream.Collectors;

/**
 * üÜï Dedicated service for Organizer Dashboard statistics
 * Provides real-time metrics for organizers
 */
@Service
@RequiredArgsConstructor
@Slf4j
public class OrganiserDashboardService {

    private final EventRepo eventRepo;
    private final TicketsRepo ticketsRepo;
    private final UserRepo userRepo;

    /**
     * ‚úÖ Get complete organizer dashboard overview
     * Shows ALL events, revenue, tickets sold, etc.
     */
    public Map<String, Object> getOrganiserOverview(UUID organiserId) {
        log.info("Fetching organiser overview for: {}", organiserId);

        User organiser = userRepo.findById(organiserId)
                .orElseThrow(() -> new IllegalStateException("Organiser not found"));

        List<Event> allEvents = organiser.getOrganisedEvents();

        // Filter published events
        List<Event> publishedEvents = allEvents.stream()
                .filter(e -> e.getEventStatus() == EventStatus.PUBLISHED)
                .collect(Collectors.toList());

        // Filter draft events
        List<Event> draftEvents = allEvents.stream()
                .filter(e -> e.getEventStatus() == EventStatus.DRAFT)
                .collect(Collectors.toList());

        // Calculate total metrics across ALL events
        long totalTicketsSold = 0;
        double totalRevenue = 0.0;
        long totalAttendees = 0;

        for (Event event : allEvents) {
            long ticketsSold = ticketsRepo.countByTicketType_Event_Id(event.getId());
            totalTicketsSold += ticketsSold;

            // Calculate revenue for this event
            List<Ticket> tickets = ticketsRepo.findAllByEventId(event.getId());
            double eventRevenue = tickets.stream()
                    .mapToDouble(Ticket::getPrice)
                    .sum();
            totalRevenue += eventRevenue;

            // Count attendees who actually showed up
            totalAttendees += event.getAttendees().size();
        }

        Map<String, Object> stringObjectMap = Map.ofEntries(
                Map.entry("organiserId", organiserId),
                Map.entry("organiserName", organiser.getName()),
                Map.entry("organiserEmail", organiser.getEmail()),
                Map.entry("totalEvents", allEvents.size()),
                Map.entry("publishedEvents", publishedEvents.size()),
                Map.entry("draftEvents", draftEvents.size()),
                Map.entry("totalTicketsSold", totalTicketsSold),
                Map.entry("totalRevenue", totalRevenue),
                Map.entry("totalAttendees", totalAttendees),
                Map.entry("averageRevenuePerEvent",
                        allEvents.isEmpty() ? 0 : totalRevenue / allEvents.size()),
                Map.entry("averageTicketsPerEvent",
                        allEvents.isEmpty() ? 0 : (double) totalTicketsSold / allEvents.size())
        );

        return stringObjectMap;
    }

    /**
     * ‚úÖ Get individual event statistics
     * Shows detailed metrics for a specific event
     */
    public Map<String, Object> getEventStatistics(UUID eventId, UUID organiserId) {
        Event event = eventRepo.findById(eventId)
                .orElseThrow(() -> new IllegalStateException("Event not found"));

        // Verify ownership
        if (!event.getOrganiser().getId().equals(organiserId)) {
            throw new IllegalStateException("You don't have permission to view this event");
        }

        // Count tickets sold
        long ticketsSold = ticketsRepo.countByTicketType_Event_Id(eventId);

        // Calculate revenue
        List<Ticket> tickets = ticketsRepo.findAllByEventId(eventId);
        double revenue = tickets.stream()
                .mapToDouble(Ticket::getPrice)
                .sum();

        // Count attendees who showed up
        long attendeesCount = event.getAttendees().size();

        // Get ticket type breakdown
        List<Map<String, Object>> ticketTypeBreakdown = event.getTicketTypes().stream()
                .map(ticketType -> {
                    long sold = ticketType.getTicket().size();
                    double typeRevenue = ticketType.getTicket().stream()
                            .mapToDouble(Ticket::getPrice)
                            .sum();

                    return Map.<String, Object>of(
                            "ticketTypeId", ticketType.getId(),
                            "ticketTypeName", ticketType.getName(),
                            "price", ticketType.getPrice(),
                            "totalAvailable", ticketType.getTotalAvailable(),
                            "sold", sold,
                            "revenue", typeRevenue,
                            "remaining", ticketType.getTotalAvailable() != null ?
                                    ticketType.getTotalAvailable() : 0
                    );
                })
                .collect(Collectors.toList());

        return Map.ofEntries(
                Map.entry("eventId", event.getId()),
                Map.entry("eventName", event.getName()),
                Map.entry("eventStatus", event.getEventStatus().name()),
                Map.entry("ticketsSold", ticketsSold),
                Map.entry("revenue", revenue),
                Map.entry("attendeesCount", attendeesCount),
                Map.entry(
                        "attendanceRate",
                        ticketsSold > 0 ? (double) attendeesCount / ticketsSold * 100 : 0
                ),
                Map.entry("ticketTypeBreakdown", ticketTypeBreakdown),
                Map.entry("startTime", event.getStartTime()),
                Map.entry("endTime", event.getEndTime()),
                Map.entry("venue", event.getVenue())
        );

    }

    /**
     * ‚úÖ Get list of attendees for an event
     * Shows who actually showed up (validated tickets)
     */
    public List<Map<String, Object>> getEventAttendees(UUID eventId, UUID organiserId) {
        Event event = eventRepo.findById(eventId)
                .orElseThrow(() -> new IllegalStateException("Event not found"));

        if (!event.getOrganiser().getId().equals(organiserId)) {
            throw new IllegalStateException("You don't have permission to view this event");
        }

        return event.getAttendees().stream()
                .map(attendee -> Map.<String, Object>of(
                        "userId", attendee.getId(),
                        "name", attendee.getName(),
                        "email", attendee.getEmail()
                ))
                .collect(Collectors.toList());
    }

    /**
     * üÜï Get revenue trend over time
     * Useful for charts/graphs
     */
    public Map<String, Object> getRevenueTrend(UUID organiserId) {
        User organiser = userRepo.findById(organiserId)
                .orElseThrow(() -> new IllegalStateException("Organiser not found"));

        List<Map<String, Object>> eventRevenues = organiser.getOrganisedEvents().stream()
                .map(event -> {
                    List<Ticket> tickets = ticketsRepo.findAllByEventId(event.getId());
                    double revenue = tickets.stream()
                            .mapToDouble(Ticket::getPrice)
                            .sum();

                    return Map.<String, Object>of(
                            "eventId", event.getId(),
                            "eventName", event.getName(),
                            "eventDate", event.getStartTime(),
                            "revenue", revenue,
                            "ticketsSold", tickets.size()
                    );
                })
                .sorted((a, b) -> ((LocalDateTime) a.get("eventDate"))
                        .compareTo((LocalDateTime) b.get("eventDate")))
                .collect(Collectors.toList());

        double totalRevenue = eventRevenues.stream()
                .mapToDouble(e -> (Double) e.get("revenue"))
                .sum();

        return Map.of(
                "totalRevenue", totalRevenue,
                "eventCount", eventRevenues.size(),
                "revenueByEvent", eventRevenues
        );
    }
}
</file>

<file path="src/main/java/com/atharv/Event_Ticket_Platform/Service/ServiceImpl/QrServiceImpl.java">
package com.atharv.Event_Ticket_Platform.Service.ServiceImpl;

import com.atharv.Event_Ticket_Platform.Domain.DTO.QrCodeDtos.QrCodeDetails;
import com.atharv.Event_Ticket_Platform.Domain.Entity.QrCode;
import com.atharv.Event_Ticket_Platform.Domain.Entity.Ticket;
import com.atharv.Event_Ticket_Platform.Domain.Enum.QrCodeStatus;
import com.atharv.Event_Ticket_Platform.Domain.Enum.TicketStatus;
import com.atharv.Event_Ticket_Platform.Domain.Mapper.TicketMapper;
import com.atharv.Event_Ticket_Platform.Exceptions.QrCodeNotFoundException;
import com.atharv.Event_Ticket_Platform.Exceptions.ResourceNotFoundException;
import com.atharv.Event_Ticket_Platform.Repository.QrCodeRepo;
import com.atharv.Event_Ticket_Platform.Repository.TicketValidationRepo;
import com.atharv.Event_Ticket_Platform.Repository.TicketsRepo;
import com.atharv.Event_Ticket_Platform.Service.ServiceInterface.QrService;
import com.atharv.Event_Ticket_Platform.util.generatePublicQrCode;
import com.google.zxing.BarcodeFormat;
import com.google.zxing.MultiFormatWriter;
import com.google.zxing.WriterException;
import com.google.zxing.client.j2se.MatrixToImageWriter;
import com.google.zxing.common.BitMatrix;
import jakarta.transaction.Transactional;
import lombok.RequiredArgsConstructor;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.stereotype.Service;

import java.io.ByteArrayOutputStream;
import java.io.IOException;
import java.time.LocalDateTime;
import java.util.List;
import java.util.Locale;
import java.util.UUID;

@Service @RequiredArgsConstructor
public class QrServiceImpl implements QrService {

    private final QrCodeRepo qrCodeRepo;
    private  static final int height=300;
    private static final int width=300;
    private final TicketValidationRepo ticketValidationRepo;
    private final TicketsRepo ticketsRepo;
    private final TicketMapper ticketMapper;

    @Value("${qr.expiry.minutes}")
    private long qrExpiryMinutes;
    private LocalDateTime qrGeneratedTime;


    @Override
    public QrCode createQr(Ticket ticket) {

        QrCode qrCode = new QrCode();
        qrCode.setTicket(ticket);
        qrCode.setQrCodeStatus(QrCodeStatus.ACTIVE);
        qrCode.setGeneratedDateTime(LocalDateTime.now());

        // generate unique public code
        String publicCode;
        do {
            publicCode = generatePublicQrCode.generate(8);
        } while (qrCodeRepo.existsByPublicCode(publicCode));

        String pc=publicCode.toUpperCase(Locale.ROOT);
        qrCode.setPublicCode(pc);

        return qrCodeRepo.save(qrCode);
    }


    @Override
public byte[] createQrImage(String QrId) throws RuntimeException, IOException, WriterException {
        BitMatrix bitMatrix=new MultiFormatWriter().encode(QrId, BarcodeFormat.QR_CODE,width,height);

        ByteArrayOutputStream outputStream=new ByteArrayOutputStream();
        MatrixToImageWriter.writeToStream(bitMatrix,"PNG",outputStream);
        return outputStream.toByteArray();
    }

    @Transactional
    @Override
    public void generateNewQrForTicket(Ticket ticket){
        List<QrCode> activeQrCodes=qrCodeRepo.findByQrCodeStatusAndTicket_Id(QrCodeStatus.ACTIVE,ticket.getId());

        for(QrCode qr : activeQrCodes){
            qr.setQrCodeStatus(QrCodeStatus.EXPIRED);
        }

        QrCode qr =createQr(ticket);
        ticket.getQrCodes().add(qr);
    }

//    @Transactional
//    @Override
//    public void scanQrOrThrow(String publicCode) {
//
//        QrCode qr = qrCodeRepo.findByPublicCode(publicCode)
//                .orElseThrow(() ->
//                        new QrCodeNotFoundException("Invalid QR code"));
//
//        Ticket ticket = qr.getTicket();
//        if (ticket == null) {
//            throw new IllegalStateException("QR not linked to ticket");
//        }
//
//        // 1. QR expiry check
//        LocalDateTime expiry =
//                qr.getGeneratedDateTime().plusMinutes(qrExpiryMinutes);
//
//        if (LocalDateTime.now().isAfter(expiry)) {
//            qr.setQrCodeStatus(QrCodeStatus.EXPIRED);
//            throw new IllegalStateException("QR expired");
//        }
//
//        // 2. QR status check
//        if (qr.getQrCodeStatus() != QrCodeStatus.ACTIVE) {
//            throw new IllegalStateException("QR already used");
//        }
//
//        // 3. Ticket status check
//        if (ticket.getStatus() != TicketStatus.PURCHASED) {
//            throw new IllegalStateException("Ticket already used or invalid");
//        }
//
//        // 4. CONSUME (atomic)
//        qr.setQrCodeStatus(QrCodeStatus.USED);
//        ticket.setStatus(TicketStatus.USED);
//    }


    @Override
    public QrCodeDetails qrCodeDetails(UUID userId, UUID ticketId) {

        Ticket ticket = ticketsRepo.findById(ticketId)
                .orElseThrow(() ->
                        new ResourceNotFoundException("Ticket not found"));

        if (!ticket.getPurchaser().getId().equals(userId)) {
            throw new IllegalStateException("This ticket does not belong to this user");
        }

        QrCode latestQr =
                qrCodeRepo.findTopByTicket_IdOrderByGeneratedDateTimeDesc(ticketId);

        return latestQr != null ? ticketMapper.toDetails(latestQr) : null;
    }


    @Transactional
    @Override
    public byte[] generateQrImage(UUID userId, UUID ticketId)
            throws IOException, WriterException {

        Ticket ticket = ticketsRepo.findById(ticketId)
                .orElseThrow(() ->
                        new ResourceNotFoundException("Ticket not found"));

        if (!ticket.getPurchaser().getId().equals(userId)) {
            throw new IllegalStateException("Unauthorized access");
        }

        // Ticket must be usable
        if (ticket.getStatus() == TicketStatus.USED) {
            throw new IllegalStateException("Ticket already used");
        }

        if (ticket.getStatus() == TicketStatus.CANCELLED) {
            throw new IllegalStateException("ticket cancelled");
        }

        QrCode qr =
                qrCodeRepo.findTopByTicket_IdOrderByGeneratedDateTimeDesc(ticketId);

        // Check if existing QR can be reused
        if (qr != null && qr.getQrCodeStatus() == QrCodeStatus.ACTIVE) {

            LocalDateTime expiry =
                    qr.getGeneratedDateTime().plusMinutes(qrExpiryMinutes);

            if (LocalDateTime.now().isBefore(expiry)) {
                return createQrImage(qr.getPublicCode());
            }

            // Expire old QR
            qr.setQrCodeStatus(QrCodeStatus.EXPIRED);
        }

        // Create new QR
        QrCode newQr = createQr(ticket);

        return createQrImage(newQr.getPublicCode());
    }





}
</file>

<file path="src/main/java/com/atharv/Event_Ticket_Platform/Service/ServiceImpl/StaffTicketValidationService.java">
package com.atharv.Event_Ticket_Platform.Service.ServiceImpl;

import com.atharv.Event_Ticket_Platform.Domain.Entity.*;
import com.atharv.Event_Ticket_Platform.Domain.Enum.*;
import com.atharv.Event_Ticket_Platform.Exceptions.QrCodeNotFoundException;
import com.atharv.Event_Ticket_Platform.Repository.*;
import jakarta.transaction.Transactional;
import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.stereotype.Service;

import java.time.LocalDateTime;
import java.util.Locale;
import java.util.UUID;

@Service
@RequiredArgsConstructor
@Slf4j
public class StaffTicketValidationService {

    private final QrCodeRepo qrCodeRepo;
    private final TicketsRepo ticketsRepo;
    private final TicketValidationRepo ticketValidationRepo;
    private final StaffRepo staffRepo;
    private final EventRepo eventRepo;
    private final UserRepo userRepo;

    @Value("${qr.expiry.minutes}")
    private long qrExpiryMinutes;

    /**
     * ‚úÖ Staff validates ticket by scanning QR code
     * This is the PRIMARY validation method
     */
    @Transactional
    public TicketValidation validateTicketByStaff(String publicCode, UUID staffUserId) {
        String normalizedCode = normalizePublicCode(publicCode);
        log.info("Staff {} attempting to validate QR code: {}", staffUserId, normalizedCode);

        Staff staff = verifyStaffAccess(staffUserId);

        QrCode qr = qrCodeRepo.findByPublicCode(normalizedCode)
                .orElseThrow(() -> new QrCodeNotFoundException("Invalid QR code"));

        Ticket ticket = qr.getTicket();
        if (ticket == null) {
            throw new IllegalStateException("QR code not linked to any ticket");
        }

        verifyTicketBelongsToStaffEvent(ticket, staff);
        validateQrCode(qr);
        validateTicketStatus(ticket);

        return performValidation(ticket, qr, staff, TicketValidationMethod.QR);
    }


    /**
     * ‚úÖ CORRECTED: Manual validation using QR public code
     *
     * Use case: Attendee verbally provides QR code, staff types it in
     *
     * IMPORTANT: This still validates the QR code's validity and expiry!
     * The only difference is the input method (typed vs scanned).
     */
    @Transactional
    public TicketValidation validateTicketManually(String publicCode, UUID staffUserId) {
        String normalizedCode = normalizePublicCode(publicCode);
        log.info("Staff {} attempting MANUAL validation with QR code: {}", staffUserId, normalizedCode);

        Staff staff = verifyStaffAccess(staffUserId);

        QrCode qr = qrCodeRepo.findByPublicCode(normalizedCode)
                .orElseThrow(() ->
                        new QrCodeNotFoundException("Invalid QR code: " + normalizedCode)
                );

        Ticket ticket = qr.getTicket();
        if (ticket == null) {
            throw new IllegalStateException("QR code not linked to any ticket");
        }

        verifyTicketBelongsToStaffEvent(ticket, staff);
        validateQrCode(qr);
        validateTicketStatus(ticket);

        return performValidation(ticket, qr, staff, TicketValidationMethod.MANUAL);
    }


    /**
     * ‚úÖ NEW: Search for ticket by public QR code before manual validation
     * Staff can verify ticket details before validating
     */
    public Ticket searchTicketForValidation(String publicCode, UUID staffUserId) {
        log.info("Staff {} searching for ticket with QR code: {}", staffUserId, publicCode);

        if (publicCode == null || publicCode.trim().isEmpty()) {
            throw new IllegalArgumentException("QR code is required for search");
        }

        Staff staff = verifyStaffAccess(staffUserId);

        QrCode qr = qrCodeRepo.findByPublicCode(publicCode.trim().toUpperCase())
                .orElseThrow(() -> new QrCodeNotFoundException("QR code not found: " + publicCode));

        Ticket ticket = qr.getTicket();
        if (ticket == null) {
            throw new IllegalStateException("QR code not linked to any ticket");
        }

        verifyTicketBelongsToStaffEvent(ticket, staff);

        // ‚úÖ Also check QR validity during search
        LocalDateTime qrExpiry = qr.getGeneratedDateTime().plusMinutes(qrExpiryMinutes);
        if (LocalDateTime.now().isAfter(qrExpiry)) {
            log.warn("QR code {} is expired", qr.getPublicCode());
            throw new IllegalStateException("QR code has expired. Attendee must regenerate QR code.");
        }

        if (qr.getQrCodeStatus() != QrCodeStatus.ACTIVE) {
            log.warn("QR code {} is not active. Status: {}", qr.getPublicCode(), qr.getQrCodeStatus());
            throw new IllegalStateException("QR code is " + qr.getQrCodeStatus().name().toLowerCase());
        }

        return ticket;
    }

    // ==================== HELPER METHODS ====================

    /**
     * Verify staff exists and has valid access
     */
    private Staff verifyStaffAccess(UUID staffUserId) {
        Staff staff = staffRepo.findByStaffUserId(staffUserId)
                .orElseThrow(() -> new IllegalStateException("Staff member not found"));

        if (!staff.getIsActive()) {
            log.warn("Inactive staff {} attempted to validate ticket", staffUserId);
            throw new IllegalStateException("Staff account is inactive");
        }

        if (staff.isExpired()) {
            log.warn("Staff {} credentials have expired", staffUserId);
            throw new IllegalStateException("Staff credentials have expired. Please contact the organiser.");
        }

        return staff;
    }

    /**
     * Verify ticket belongs to staff's assigned event
     */
    private void verifyTicketBelongsToStaffEvent(Ticket ticket, Staff staff) {
        Event ticketEvent = ticket.getTicketType().getEvent();
        if (!ticketEvent.getId().equals(staff.getEventId())) {
            log.warn("Staff {} tried to validate ticket for different event. Staff event: {}, Ticket event: {}",
                    staff.getStaffUserId(), staff.getEventId(), ticketEvent.getId());
            throw new IllegalStateException("This ticket is for a different event");
        }
    }

    /**
     * ‚úÖ Validate QR code status and expiry
     * CRITICAL: This prevents expired/used QR codes from being validated
     */
    private void validateQrCode(QrCode qr) {
        LocalDateTime qrExpiry = qr.getGeneratedDateTime().plusMinutes(qrExpiryMinutes);
        LocalDateTime now = LocalDateTime.now();

        if (now.isAfter(qrExpiry)) {
            qr.setQrCodeStatus(QrCodeStatus.EXPIRED);
            qrCodeRepo.save(qr);
            log.warn("QR code {} has expired. Generated: {}, Expiry: {}, Now: {}",
                    qr.getPublicCode(), qr.getGeneratedDateTime(), qrExpiry, now);
            throw new IllegalStateException(
                    String.format("QR code expired %d minutes ago. Attendee must regenerate QR code.",
                            java.time.Duration.between(qrExpiry, now).toMinutes())
            );
        }

        if (qr.getQrCodeStatus() != QrCodeStatus.ACTIVE) {
            log.warn("QR code {} is not active. Status: {}", qr.getPublicCode(), qr.getQrCodeStatus());
            throw new IllegalStateException("QR code already " + qr.getQrCodeStatus().name().toLowerCase());
        }
    }

    /**
     * Validate ticket status
     */
    private void validateTicketStatus(Ticket ticket) {
        if (ticket.getStatus() == TicketStatus.USED) {
            log.warn("Ticket {} already used", ticket.getId());
            throw new IllegalStateException("Ticket has already been used for entry");
        }

        if (ticket.getStatus() == TicketStatus.CANCELLED) {
            log.warn("Ticket {} is cancelled", ticket.getId());
            throw new IllegalStateException("Ticket has been cancelled");
        }

        if (ticket.getStatus() != TicketStatus.PURCHASED) {
            log.warn("Ticket {} is not in PURCHASED state. Status: {}", ticket.getId(), ticket.getStatus());
            throw new IllegalStateException("Invalid ticket status: " + ticket.getStatus().name());
        }
    }

    /**
     * ‚úÖ Perform the actual validation and create records
     * Now accepts QrCode parameter to mark it as USED
     */
    private TicketValidation performValidation(
            Ticket ticket,
            QrCode qr,
            Staff staff,
            TicketValidationMethod method
    ) {
        // Mark ticket as USED
        ticket.setStatus(TicketStatus.USED);
        ticketsRepo.save(ticket);

        // ‚úÖ ALWAYS mark QR as USED (both for QR scan and manual entry)
        qr.setQrCodeStatus(QrCodeStatus.EXPIRED);
        qrCodeRepo.save(qr);

        // Create validation record
        Event event = ticket.getTicketType().getEvent();
        TicketValidation validation = TicketValidation.builder()
                .ticket(ticket)
                .staff(staff)
                .event(event)
                .validationStatus(TicketValidationStatus.VALID)
                .validatedAt(LocalDateTime.now())
                .ValidationMethod(method)
                .build();

        TicketValidation savedValidation = ticketValidationRepo.save(validation);

        // Update staff last login
        staff.setLastLogin(LocalDateTime.now());
        staffRepo.save(staff);

        log.info("‚úÖ Ticket {} successfully validated by staff {} using {} (QR: {})",
                ticket.getId(), staff.getStaffUserId(), method, qr.getPublicCode());

        registerAttendeeForEvent(ticket);

        return savedValidation;
    }

    private String normalizePublicCode(String publicCode) {
        if (publicCode == null) {
            throw new IllegalArgumentException("QR code is required");
        }
        return publicCode.trim().toUpperCase(Locale.ROOT);
    }

    private void registerAttendeeForEvent(Ticket ticket) {
        User attendee = ticket.getPurchaser();
        Event event = ticket.getTicketType().getEvent();

        // Check if attendee is already registered for this event
        boolean alreadyAttending = attendee.getAttendingEvents().stream()
                .anyMatch(e -> e.getId().equals(event.getId()));

        if (!alreadyAttending) {
            // Add attendee to event's attendees list
            event.getAttendees().add(attendee);

            // Add event to attendee's attending events list
            attendee.getAttendingEvents().add(event);

            // Save both sides of the relationship
            eventRepo.save(event);
            userRepo.save(attendee);

            log.info("‚úÖ Registered attendee {} for event {} via ticket validation",
                    attendee.getId(), event.getId());
        } else {
            log.debug("Attendee {} already registered for event {}",
                    attendee.getId(), event.getId());
        }
    }

}
</file>

<file path="src/main/java/com/atharv/Event_Ticket_Platform/Service/ServiceImpl/TicketServiceImpl.java">
package com.atharv.Event_Ticket_Platform.Service.ServiceImpl;

import com.atharv.Event_Ticket_Platform.Domain.DTO.TicketDtos.TicketPurchasedDetails;
import com.atharv.Event_Ticket_Platform.Domain.Entity.Ticket;
import com.atharv.Event_Ticket_Platform.Domain.Entity.TicketType;
import com.atharv.Event_Ticket_Platform.Domain.Entity.User;
import com.atharv.Event_Ticket_Platform.Domain.Enum.TicketStatus;
import com.atharv.Event_Ticket_Platform.Domain.Mapper.TicketMapper;
import com.atharv.Event_Ticket_Platform.Exceptions.ResourceNotFoundException;
import com.atharv.Event_Ticket_Platform.Exceptions.TicketSoldOutException;
import com.atharv.Event_Ticket_Platform.Exceptions.UserNotFoundExceptions;
import com.atharv.Event_Ticket_Platform.Repository.TicketTypeRepo;
import com.atharv.Event_Ticket_Platform.Repository.TicketsRepo;
import com.atharv.Event_Ticket_Platform.Repository.UserRepo;
import com.atharv.Event_Ticket_Platform.Service.ServiceInterface.QrService;
import com.atharv.Event_Ticket_Platform.Service.ServiceInterface.TicketService;
import jakarta.transaction.Transactional;
import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;
import org.springframework.data.domain.Page;
import org.springframework.data.domain.Pageable;
import org.springframework.stereotype.Service;

import java.time.LocalDateTime;
import java.util.UUID;

@Service @RequiredArgsConstructor @Slf4j
public class TicketServiceImpl implements TicketService {
    private final TicketsRepo ticketsRepo;
    private final TicketTypeRepo ticketTypeRepo;
    private final UserRepo userRepo;
    private final QrService qrService;
    private final TicketMapper ticketMapper;

    @Transactional
    @Override
    public Ticket purchaseTicket(UUID userId, Integer ticketTypeId) {
        // VERIFY THE USER
        User user = userRepo.findById(userId).orElseThrow(()->new UserNotFoundExceptions(String.format("user with id : %s not found",userId)));

        // verify the ticketType
        TicketType ticketType=ticketTypeRepo.findByIdForUpdate(ticketTypeId).orElseThrow(()->new ResourceNotFoundException (String.format("TicketType with ID : %s not found",ticketTypeId)));


        // 3. Verify event sales window
        LocalDateTime salesStartTime = ticketType.getEvent().getSalesStartDate();
        LocalDateTime salesEndTime = ticketType.getEvent().getSalesEndDate();

        if (salesStartTime == null || salesEndTime == null) {
            throw new IllegalStateException("Event sales dates not configured");
        }

        LocalDateTime now = LocalDateTime.now();
        if (now.isBefore(salesStartTime)) {
            throw new IllegalStateException("Ticket sales have not started yet");
        }

        if (now.isAfter(salesEndTime)) {
            throw new IllegalStateException("Ticket sales have ended");
        }


        // user can purchase ticket if the tickets are available
        if(ticketType.getTotalAvailable()==null || ticketType.getTotalAvailable()<=0){
            log.info("TotalAvailable Tickets for this TicketType is 0");
            throw new TicketSoldOutException(String.format("Tickets sold out for this ticketType : %s",ticketTypeId));
        }


        Ticket ticket = Ticket.builder()
                .ticketType(ticketType)
                .purchaser(user)
                .price(ticketType.getPrice())
                .status(TicketStatus.PURCHASED)
                .build();

        ticketType.setTotalAvailable(ticketType.getTotalAvailable()-1);
        ticketTypeRepo.save(ticketType);
        Ticket savedTicket = ticketsRepo.save(ticket);
        log.info("Ticket purchased successfully - Ticket ID: {}",
                savedTicket.getId());
        return savedTicket;

    }

    @Override
    public Page<Ticket> listAllTicketsForThisUser(UUID userID, Pageable pageable) {
        log.info("Fetching tickets for user: {}", userID);
        Page<Ticket> ticketsOfUser = ticketsRepo.findByPurchaser_Id(userID, pageable);

        if (ticketsOfUser.isEmpty()) {
            log.info("No tickets found for user: {}", userID);
        }

        return ticketsOfUser;
    }

    @Override
    public TicketPurchasedDetails getTicketDetails
            (UUID userId, UUID ticketId) {

        Ticket ticket=ticketsRepo.findById(ticketId).orElseThrow(()->new ResourceNotFoundException(String.format("ticket with id : %s not found",ticketId)));

        if(!ticket.getPurchaser().getId().equals(userId)){
            throw new IllegalStateException("this ticket doesn't belong to this user");
        }

        // create TicketPurchaseDetails
        TicketPurchasedDetails ticketPurchasedDetails=ticketMapper.toDetails(ticket);
        return ticketPurchasedDetails;

    }


    @Transactional
    @Override
    public void cancelTicket(UUID userId, UUID ticketId) {
        log.info("Cancelling ticket - UserId: {}, TicketId: {}", userId, ticketId);

        Ticket ticket = ticketsRepo.findById(ticketId)
                .orElseThrow(() -> new ResourceNotFoundException(
                        String.format("Ticket with id: %s not found", ticketId)
                ));

        if (!ticket.getPurchaser().getId().equals(userId)) {
            throw new IllegalStateException("This ticket does not belong to this user");
        }

        if (ticket.getStatus() == TicketStatus.USED) {
            throw new IllegalStateException("Cannot cancel a used ticket");
        }

        if (ticket.getStatus() == TicketStatus.CANCELLED) {
            throw new IllegalStateException("Ticket already cancelled");
        }

        // Mark as cancelled and restore ticket availability
        ticket.setStatus(TicketStatus.CANCELLED);

        TicketType ticketType = ticket.getTicketType();
        ticketType.setTotalAvailable(ticketType.getTotalAvailable() + 1);

        ticketTypeRepo.save(ticketType);
        ticketsRepo.save(ticket);

        log.info("Ticket cancelled successfully - TicketId: {}", ticketId);
    }





}
</file>

<file path="src/main/java/com/atharv/Event_Ticket_Platform/Service/ServiceImpl/UserServiceImpl.java">
package com.atharv.Event_Ticket_Platform.Service.ServiceImpl;

import com.atharv.Event_Ticket_Platform.Domain.Entity.User;
import com.atharv.Event_Ticket_Platform.Repository.UserRepo;
import com.atharv.Event_Ticket_Platform.Service.ServiceInterface.UserService;
import jakarta.transaction.Transactional;
import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;
import org.springframework.security.oauth2.jwt.Jwt;
import org.springframework.stereotype.Service;

import java.util.Optional;
import java.util.UUID;

@Service
@RequiredArgsConstructor
@Slf4j
public class UserServiceImpl implements UserService {
    private final UserRepo userRepo;


    @Transactional
    @Override
    public User ensureUserExists(UUID keycloakId, Jwt jwt) {
        log.info("=== ensureUserExists called for keycloakId: {}", keycloakId);

        // Check if user already exists in database
        Optional<User> existingUser = userRepo.findById(keycloakId);

        if (existingUser.isPresent()) {
            User user = existingUser.get();
            log.info("User FOUND in DB - ID: {}, Email: {}, createdAt: {}, updatedAt: {}",
                    user.getId(), user.getEmail(), user.getCreatedAt(), user.getUpdatedAt());
            return user;
        } else {
            log.info("User NOT FOUND - Creating new user from JWT");

            // Extract user information from JWT claims
            String name = jwt.getClaimAsString("name");
            String email = jwt.getClaimAsString("email");
            String preferredUsername = jwt.getClaimAsString("preferred_username");

            // Log JWT claims for debugging
            log.debug("JWT Claims - name: {}, email: {}, preferred_username: {}",
                    name, email, preferredUsername);

            // Build new user entity
            User user = User.builder()
                    .id(keycloakId)
                    .name(name != null ? name : (preferredUsername != null ? preferredUsername : "Unknown"))
                    .email(email != null ? email : "unknown@example.com")
                    .build();

            // Save to database with flush to ensure immediate persistence
            User savedUser = userRepo.saveAndFlush(user);

            log.info("User CREATED - ID: {}, Email: {}, Name: {}, createdAt: {}, updatedAt: {}",
                    savedUser.getId(),
                    savedUser.getEmail(),
                    savedUser.getName(),
                    savedUser.getCreatedAt(),
                    savedUser.getUpdatedAt());

            return savedUser;
        }
    }}
</file>

<file path="src/main/java/com/atharv/Event_Ticket_Platform/Service/ServiceImpl/ValidationStatsService.java">
package com.atharv.Event_Ticket_Platform.Service.ServiceImpl;

import com.atharv.Event_Ticket_Platform.Domain.DTO.TicketTypeDto.TicketTypeRevenueDto;
import com.atharv.Event_Ticket_Platform.Domain.DTO.TicketValidationDtos.*;
import com.atharv.Event_Ticket_Platform.Domain.Entity.*;
import com.atharv.Event_Ticket_Platform.Domain.Enum.TicketValidationStatus;
import com.atharv.Event_Ticket_Platform.Repository.*;
import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;
import org.springframework.data.domain.Page;
import org.springframework.data.domain.Pageable;
import org.springframework.stereotype.Service;

import java.time.Duration;
import java.time.LocalDateTime;
import java.util.List;
import java.util.Map;
import java.util.UUID;
import java.util.stream.Collectors;

@Service
@RequiredArgsConstructor
@Slf4j
public class ValidationStatsService {

    private final TicketValidationRepo ticketValidationRepo;
    private final TicketsRepo ticketsRepo;
    private final StaffRepo staffRepo;
    private final EventRepo eventRepo;
    private final TicketTypeRepo ticketTypeRepo;

    // ==================== ORGANIZER DASHBOARD METHODS ====================

    /**
     * üÜï Complete event dashboard with revenue statistics
     */
    public Map<String, Object> getEventDashboardStats(UUID eventId) {
        Event event = eventRepo.findById(eventId)
                .orElseThrow(() -> new IllegalStateException("Event not found"));

        long totalSold = ticketsRepo.countByTicketType_Event_Id(eventId);
        long totalValidated = ticketValidationRepo.countByEvent_IdAndValidationStatus(
                eventId, TicketValidationStatus.VALID
        );

        // ‚úÖ Calculate revenue
        double totalRevenue = calculateTotalRevenue(eventId);
        List<TicketTypeRevenueDto> revenueByTicketType = calculateRevenueByTicketType(eventId);

        return Map.of(
                "eventId", event.getId(),
                "eventName", event.getName(),
                "totalTicketsSold", totalSold,
                "totalValidated", totalValidated,
                "remainingAttendees", totalSold - totalValidated,
                "totalRevenue", totalRevenue,
                "revenueByTicketType", revenueByTicketType
        );
    }

    /**
     * üÜï Calculate total revenue for an event
     */
    private double calculateTotalRevenue(UUID eventId) {
        List<Ticket> tickets = ticketsRepo.findAllByEventId(eventId);
        return tickets.stream()
                .mapToDouble(Ticket::getPrice)
                .sum();
    }

    /**
     * üÜï Calculate revenue breakdown by ticket type
     */
    private List<TicketTypeRevenueDto> calculateRevenueByTicketType(UUID eventId) {
        Event event = eventRepo.findById(eventId)
                .orElseThrow(() -> new IllegalStateException("Event not found"));

        return event.getTicketTypes().stream()
                .map(ticketType -> {
                    List<Ticket> soldTickets = ticketType.getTicket();
                    long ticketsSold = soldTickets.size();
                    double revenue = soldTickets.stream()
                            .mapToDouble(Ticket::getPrice)
                            .sum();

                    return TicketTypeRevenueDto.builder()
                            .ticketTypeId(ticketType.getId())
                            .ticketTypeName(ticketType.getName())
                            .ticketsSold(ticketsSold)
                            .revenue(revenue)
                            .averagePrice(ticketsSold > 0 ? revenue / ticketsSold : 0)
                            .build();
                })
                .collect(Collectors.toList());
    }

    /**
     * Get all staff members and their validation counts for an event
     */
    public List<StaffValidationStatsDto> getAllStaffStatsForEvent(UUID eventId, UUID organiserId) {
        Event event = eventRepo.findById(eventId)
                .orElseThrow(() -> new IllegalStateException("Event not found"));

        if (!event.getOrganiser().getId().equals(organiserId)) {
            throw new IllegalStateException("You don't have permission to view this event");
        }

        List<Staff> staffList = staffRepo.findByCreatedByOrganiserIdAndEventId(organiserId, eventId);

        return staffList.stream()
                .map(staff -> {
                    long validatedCount = ticketValidationRepo
                            .countByEvent_IdAndValidationStatusAndStaff_StaffUserId(
                                    eventId,
                                    TicketValidationStatus.VALID,
                                    staff.getStaffUserId()
                            );

                    return StaffValidationStatsDto.builder()
                            .staffUserId(staff.getStaffUserId())
                            .staffUsername(staff.getUsername())
                            .validatedCount(validatedCount)
                            .build();
                })
                .collect(Collectors.toList());
    }

    /**
     * Get detailed list of attendees validated by a specific staff member
     */
    public Page<ValidationHistoryDto> getAttendeesValidatedByStaff(
            UUID eventId,
            UUID staffUserId,
            UUID organiserId,
            Pageable pageable
    ) {
        Event event = eventRepo.findById(eventId)
                .orElseThrow(() -> new IllegalStateException("Event not found"));

        if (!event.getOrganiser().getId().equals(organiserId)) {
            throw new IllegalStateException("You don't have permission to view this event");
        }

        Staff staff = staffRepo.findByStaffUserId(staffUserId)
                .orElseThrow(() -> new IllegalStateException("Staff not found"));

        if (!staff.getEventId().equals(eventId)) {
            throw new IllegalStateException("Staff is not assigned to this event");
        }

        Page<TicketValidation> validations = ticketValidationRepo
                .findByEvent_IdAndStaff_StaffUserId(eventId, staffUserId, pageable);

        return validations.map(validation -> ValidationHistoryDto.builder()
                .validationId(validation.getId())
                .ticketId(validation.getTicket().getId())
                .ticketTypeName(validation.getTicket().getTicketType().getName())
                .attendeeName(validation.getTicket().getPurchaser().getName())
                .attendeeEmail(validation.getTicket().getPurchaser().getEmail())
                .validationMethod(validation.getValidationMethod().name())
                .validationStatus(validation.getValidationStatus().name())
                .validatedAt(validation.getValidatedAt())
                .build()
        );
    }

    /**
     * Get validation stats per ticket type for an event
     */
    public List<TicketTypeAttendanceDto> getValidatedAttendeesPerTicketType(UUID eventId, UUID organiserId) {
        Event event = eventRepo.findById(eventId)
                .orElseThrow(() -> new IllegalStateException("Event not found"));

        if (!event.getOrganiser().getId().equals(organiserId)) {
            throw new IllegalStateException("You don't have permission to view this event");
        }

        return event.getTicketTypes().stream()
                .map(ticketType -> {
                    long validatedCount = ticketValidationRepo
                            .countByEvent_IdAndTicket_TicketType_IdAndValidationStatus(
                                    eventId,
                                    ticketType.getId(),
                                    TicketValidationStatus.VALID
                            );

                    return TicketTypeAttendanceDto.builder()
                            .ticketTypeId(ticketType.getId())
                            .ticketTypeName(ticketType.getName())
                            .validatedCount(validatedCount)
                            .build();
                })
                .collect(Collectors.toList());
    }

    // ==================== STAFF PERSONAL METHODS ====================

    /**
     * üÜï Get personal stats for a staff member
     * Shows what THEY can see on their dashboard
     */
    public Map<String, Object> getStaffPersonalStats(UUID staffUserId) {
        log.info("Getting stats for staff: {}", staffUserId);

        Staff staff = staffRepo.findByStaffUserId(staffUserId)
                .orElseThrow(() -> {
                    log.error("Staff not found: {}", staffUserId);
                    return new IllegalStateException("Staff not found");
                });

        log.info("Staff found: username={}, eventId={}, validUntil={}",
                staff.getUsername(), staff.getEventId(), staff.getValidUntil());

        long totalValidated = ticketValidationRepo
                .countByEvent_IdAndValidationStatusAndStaff_StaffUserId(
                        staff.getEventId(),
                        TicketValidationStatus.VALID,
                        staff.getStaffUserId()
                );

        Event event = eventRepo.findById(staff.getEventId())
                .orElseThrow(() -> new IllegalStateException("Event not found"));

        // ‚úÖ FIX: Calculate time until expiry safely
        LocalDateTime now = LocalDateTime.now();
        Duration timeUntilExpiry = Duration.between(now, staff.getValidUntil());

        // Handle negative durations (already expired)
        long hoursRemaining = Math.max(0, timeUntilExpiry.toHours());
        long minutesRemaining = Math.max(0, timeUntilExpiry.toMinutes() % 60);

        // ‚úÖ Alternative: Calculate time since expiry if expired
        boolean isExpired = staff.isExpired();
        long hoursSinceExpiry = isExpired ? Math.abs(timeUntilExpiry.toHours()) : 0;
        long minutesSinceExpiry = isExpired ? Math.abs(timeUntilExpiry.toMinutes() % 60) : 0;

        return Map.ofEntries(
                Map.entry("staffUsername", staff.getUsername()),
                Map.entry("eventId", staff.getEventId()),
                Map.entry("eventName", event.getName()),
                Map.entry("totalValidated", totalValidated),
                Map.entry("credentialValidFrom", staff.getValidFrom()),
                Map.entry("credentialValidUntil", staff.getValidUntil()),
                Map.entry("isExpired", isExpired),
                Map.entry("hoursRemaining", hoursRemaining),
                Map.entry("minutesRemaining", minutesRemaining),
                Map.entry("hoursSinceExpiry", hoursSinceExpiry),
                Map.entry("minutesSinceExpiry", minutesSinceExpiry),
                Map.entry("isActive", staff.getIsActive())
        );

    }

    /**
     * üÜï Get staff validation history (what tickets they validated)
     */
    public Page<ValidationHistoryDto> getStaffValidationHistory(
            UUID staffUserId,
            Pageable pageable
    ) {
        Staff staff = staffRepo.findByStaffUserId(staffUserId)
                .orElseThrow(() -> new IllegalStateException("Staff not found"));

        Page<TicketValidation> validations = ticketValidationRepo
                .findByEvent_IdAndStaff_StaffUserId(
                        staff.getEventId(),
                        staffUserId,
                        pageable
                );

        return validations.map(validation -> ValidationHistoryDto.builder()
                .validationId(validation.getId())
                .ticketId(validation.getTicket().getId())
                .ticketTypeName(validation.getTicket().getTicketType().getName())
                .attendeeName(validation.getTicket().getPurchaser().getName())
                .attendeeEmail(validation.getTicket().getPurchaser().getEmail())
                .validationMethod(validation.getValidationMethod().name())
                .validationStatus(validation.getValidationStatus().name())
                .validatedAt(validation.getValidatedAt())
                .build()
        );
    }

    /**
     * üÜï Get staff validations grouped by ticket type
     */
    public List<TicketTypeAttendanceDto> getStaffValidationsByTicketType(UUID staffUserId) {
        Staff staff = staffRepo.findByStaffUserId(staffUserId)
                .orElseThrow(() -> new IllegalStateException("Staff not found"));

        Event event = eventRepo.findById(staff.getEventId())
                .orElseThrow(() -> new IllegalStateException("Event not found"));

        return event.getTicketTypes().stream()
                .map(ticketType -> {
                    long validatedCount = ticketValidationRepo
                            .countByStaff_StaffUserIdAndTicket_TicketType_IdAndValidationStatus(
                                    staffUserId,
                                    ticketType.getId(),
                                    TicketValidationStatus.VALID
                            );

                    return TicketTypeAttendanceDto.builder()
                            .ticketTypeId(ticketType.getId())
                            .ticketTypeName(ticketType.getName())
                            .validatedCount(validatedCount)
                            .build();
                })
                .collect(Collectors.toList());
    }

    /**
     * üÜï Get staff credential information
     */
    public Map<String, Object> getStaffCredentialInfo(UUID staffUserId) {
        Staff staff = staffRepo.findByStaffUserId(staffUserId)
                .orElseThrow(() -> new IllegalStateException("Staff not found"));

        LocalDateTime now = LocalDateTime.now();
        Duration timeUntilExpiry = Duration.between(now, staff.getValidUntil());

        return Map.of(
                "username", staff.getUsername(),
                "email", staff.getEmail(),
                "validFrom", staff.getValidFrom(),
                "validUntil", staff.getValidUntil(),
                "isActive", staff.getIsActive(),
                "isExpired", staff.isExpired(),
                "hoursRemaining", Math.max(0, timeUntilExpiry.toHours()),
                "minutesRemaining", Math.max(0, timeUntilExpiry.toMinutes() % 60),
                "createdAt", staff.getCreatedAt(),
                "lastLogin", staff.getLastLogin()
        );
    }

    /**
     * Legacy method - kept for backward compatibility
     */
    public StaffValidationStatsDto getStaffStats(UUID staffUserId) {
        Staff staff = staffRepo.findByStaffUserId(staffUserId)
                .orElseThrow(() -> new IllegalStateException("Staff not found"));

        long validatedByStaff = ticketValidationRepo
                .countByEvent_IdAndValidationStatusAndStaff_StaffUserId(
                        staff.getEventId(),
                        TicketValidationStatus.VALID,
                        staff.getStaffUserId()
                );

        return StaffValidationStatsDto.builder()
                .staffUserId(staff.getStaffUserId())
                .staffUsername(staff.getUsername())
                .validatedCount(validatedByStaff)
                .build();
    }
}
</file>

<file path="src/main/java/com/atharv/Event_Ticket_Platform/Service/ServiceInterface/EventService.java">
package com.atharv.Event_Ticket_Platform.Service.ServiceInterface;

import com.atharv.Event_Ticket_Platform.Domain.DTO.EventDtos.UpdateEventRequestDto;
import com.atharv.Event_Ticket_Platform.Domain.Entity.Event;
import com.atharv.Event_Ticket_Platform.Domain.Requests.CreateEventRequest;
import org.springframework.data.domain.Page;
import org.springframework.data.domain.Pageable;
import org.springframework.security.oauth2.jwt.Jwt;

import java.nio.channels.FileChannel;
import java.util.Optional;
import java.util.UUID;

public interface EventService {
    Event createEvent(UUID organiserId, CreateEventRequest eventRequest, Jwt jwt);
    Page<Event> listEventForOrganiser(UUID organiser,Pageable pageable);
    Event updateEvent(UUID organiserId, UUID eventId, UpdateEventRequestDto updateEventRequestDto);
    Event getEvent(UUID eventId,UUID organiserId);

    void deleteEvent(UUID eventId,UUID organiser);

    void deleteTicketType(UUID organiserId, UUID eventId, Integer ticketTypeId);

    Page<Event> listPublishedEvents(Pageable pageable);

    Page<Event> searchPublishedEvents(String searchTerm, Pageable pageable);

    Optional<Event> getPublishedEventById(UUID eventId);
}
</file>

<file path="src/main/java/com/atharv/Event_Ticket_Platform/Service/ServiceInterface/QrService.java">
package com.atharv.Event_Ticket_Platform.Service.ServiceInterface;

import com.atharv.Event_Ticket_Platform.Domain.DTO.QrCodeDtos.QrCodeDetails;
import com.atharv.Event_Ticket_Platform.Domain.Entity.QrCode;
import com.atharv.Event_Ticket_Platform.Domain.Entity.Ticket;
import com.google.zxing.WriterException;
import jakarta.transaction.Transactional;
import org.springframework.stereotype.Service;

import java.io.IOException;
import java.util.UUID;


public interface QrService {
    QrCode createQr(Ticket ticket);


    byte[] createQrImage(String QrId) throws RuntimeException, IOException, WriterException;

    @Transactional
    void generateNewQrForTicket(Ticket ticket);


//    @Transactional
//    void scanQrOrThrow(String publicCode);

    QrCodeDetails qrCodeDetails(UUID userId, UUID ticketId);

    @Transactional
    byte[] generateQrImage(UUID userId, UUID ticketId)
            throws IOException, WriterException;
}
</file>

<file path="src/main/java/com/atharv/Event_Ticket_Platform/Service/ServiceInterface/TicketService.java">
package com.atharv.Event_Ticket_Platform.Service.ServiceInterface;

import com.atharv.Event_Ticket_Platform.Domain.DTO.TicketDtos.TicketPurchasedDetails;
import com.atharv.Event_Ticket_Platform.Domain.Entity.Ticket;
import jakarta.transaction.Transactional;
import org.springframework.data.domain.Page;
import org.springframework.data.domain.Pageable;

import java.util.UUID;

public interface TicketService {
    Ticket purchaseTicket(UUID userId , Integer ticketTypeId);

    Page<Ticket> listAllTicketsForThisUser(UUID userID, Pageable pageable);

    TicketPurchasedDetails getTicketDetails
            (UUID userId, UUID ticketId);

    @Transactional
    void cancelTicket(UUID userId, UUID ticketId);
}
</file>

<file path="src/main/java/com/atharv/Event_Ticket_Platform/Service/ServiceInterface/TicketTypeService.java">
package com.atharv.Event_Ticket_Platform.Service.ServiceInterface;

import com.atharv.Event_Ticket_Platform.Domain.Entity.Ticket;
import com.atharv.Event_Ticket_Platform.Domain.Entity.TicketType;

import java.util.UUID;

public interface TicketTypeService {
    Ticket purchaseTicket(UUID purchaserId,Integer TicketTypeId);
}
</file>

<file path="src/main/java/com/atharv/Event_Ticket_Platform/Service/ServiceInterface/UserService.java">
package com.atharv.Event_Ticket_Platform.Service.ServiceInterface;

import com.atharv.Event_Ticket_Platform.Domain.Entity.User;
import org.springframework.security.oauth2.jwt.Jwt;

import java.util.UUID;

public interface UserService {
    User ensureUserExists(UUID keycloakId, Jwt jwt);
}
</file>

<file path="src/main/java/com/atharv/Event_Ticket_Platform/util/generatePublicQrCode.java">
package com.atharv.Event_Ticket_Platform.util;

import java.util.Random;

public class generatePublicQrCode {
    private static final String ALPHA_NUMERIC_STRING = "ABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789abcdefghijklmnopqrstuv";

    public static String generate(int length) {
        StringBuilder builder = new StringBuilder(length);
        Random random = new Random();
        for (int i = 0; i < length; i++) {
            int characterIndex = random.nextInt(ALPHA_NUMERIC_STRING.length());
            builder.append(ALPHA_NUMERIC_STRING.charAt(characterIndex));
        }
        return builder.toString();
    }
}
</file>

<file path="src/main/java/com/atharv/Event_Ticket_Platform/util/UserFromJwt.java">
package com.atharv.Event_Ticket_Platform.util;


import org.springframework.security.oauth2.jwt.Jwt;

import java.util.UUID;

public final class UserFromJwt {
    private UserFromJwt(){}
    public static UUID parseUserId(Jwt jwt){
        return UUID.fromString(jwt.getSubject());
    }
}
</file>

<file path="src/main/java/com/atharv/Event_Ticket_Platform/EventTicketPlatformApplication.java">
package com.atharv.Event_Ticket_Platform;

import org.springframework.boot.SpringApplication;
import org.springframework.boot.autoconfigure.SpringBootApplication;
import org.springframework.data.jpa.repository.config.EnableJpaAuditing;

@SpringBootApplication
@EnableJpaAuditing
public class EventTicketPlatformApplication {

    public static void main(String[] args) {
        SpringApplication.run(EventTicketPlatformApplication.class, args);
    }
}
</file>

<file path="src/main/resources/application.properties">
spring.application.name=Event-Ticket-Platform
# Database Connection
spring.datasource.url=jdbc:postgresql://localhost:5432/postgres
spring.datasource.username=postgres
spring.datasource.password=changemeinprod!

# JPA Configuration
spring.jpa.hibernate.ddl-auto=update
spring.jpa.show-sql=true
spring.jpa.properties.hibernate.format_sql=true
spring.jpa.properties.hibernate.dialect=org.hibernate.dialect.PostgreSQLDialect

spring.security.oauth2.resourceserver.jwt.issuer-uri=http://localhost:9090/realms/event-ticket-platform

# Enable SQL logging

# Show parameter binding
logging.level.org.hibernate.type.descriptor.sql.BasicBinder=TRACE

# Show Hibernate operations
logging.level.org.hibernate.SQL=DEBUG
logging.level.org.hibernate.type=TRACE
logging.level.org.hibernate.engine.transaction=DEBUG

# Your app logging
logging.level.com.atharv.Event_Ticket_Platform=DEBUG

qr.expiry.minutes=5

keycloak.admin.client-secret=MlY0kCJbnWgptm3CO4vYdDd7johM90LS

# Existing OAuth2 config
# NEW: Keycloak Admin Client Configuration
keycloak.admin.server-url=http://localhost:9090
keycloak.admin.realm=event-ticket-platform
keycloak.admin.client-id=admin-cli
keycloak.admin.username=admin
keycloak.admin.password=admin

# Keycloak realm roles
keycloak.roles.attendee=ROLE_ATTENDEE
keycloak.roles.organiser=ROLE_ORGANISER
keycloak.roles.staff=ROLE_STAFF
</file>

<file path="src/main/Theory/Production-Theory/database-entity.txt">
while overriding the equals & hashcode in entity classes , use the immutable fields which are not going to change forever , so it can be id , but if the id is gonna be autogenerated by db , then it means that before persistance it was null , then it changed to some string or uuid , so it is not actually immutable

here in this project we get the id of user from jwt(keycloak) so we there is no GeneratedValue for id in user entity , so we used id for overriding the equals and hash

if the id is generated by db then handle it by using the

@Override
public boolean equals(Object o) {
    if (this == o) return true;
    if (!(o instanceof User)) return false;

    User other = (User) o;

    // Only compare if both are persisted
    if (id == null || other.id == null) {
        return false;
    }

    return id.equals(other.id);
}


@Override
public int hashCode() {
    // Stable hash code after persistence
    return (id != null) ? id.hashCode() : System.identityHashCode(this);
}


@Override
                   public int hashCode() {
                       // Stable hash code after persistence
                       return (id != null) ? id.hashCode() : System.identityHashCode(this);
                   }
                   in hash
</file>

<file path="src/main/Theory/Production-Theory/Dtos">
never uses entity classes for the api requests/reponse , always use DTO's
</file>

<file path="src/main/Theory/@RestControllerAdvice.txt">
@RestControllerAdvice is global exception handler , that handles all the exceptions of the controller classes

@BindingResult contains
BindingResult
‚îú‚îÄ‚îÄ objectName = "createEventRequestDto"
‚îú‚îÄ‚îÄ target = CreateEventRequestDto
‚îú‚îÄ‚îÄ errorCount = 3
‚îú‚îÄ‚îÄ hasErrors = true
‚îú‚îÄ‚îÄ fieldErrors = [
‚îÇ     FieldError(name, "", "Event name is required"),
‚îÇ     FieldError(startTime, null, "Start time is required"),
‚îÇ     FieldError(endTime, 2020-01-01T10:00, "End time must be in the future")
‚îÇ   ]
‚îú‚îÄ‚îÄ globalErrors = []‚îÇ
‚îî‚îÄ‚îÄ suppressedFields = []
</file>

<file path="src/main/Theory/day 1.txt">
postgreSQL runs in docker for local consistent environment
Adminer Provides a web interface to maange the database
Spring boot connects to postgreSQL using configuration properties

docker is like virtual machine for ome app , it lets you to run applications in isolated environment
</file>

<file path="src/main/Theory/equals & hash.txt">
If two objects are equal according to equals(),
then they MUST return the same hashCode().
</file>

<file path="src/main/Theory/FlowOfProject.txt">
Client
  ‚Üì
Keycloak (JWT)
  ‚Üì
Spring Security
  ‚Üì
Controller
  ‚Üì
DTO ‚Üí Request
  ‚Üì
Service (business logic)
  ‚Üì
Entity
  ‚Üì
Database
  ‚Üì
Entity
  ‚Üì
  Response Dto
    ‚Üì
Client
</file>

<file path="src/main/Theory/keycloak.txt">
1. Realms
What is a realm?
A realm is like a separate account system.
Each realm has its own:
Users
Roles
Login rules

One project = one realm

Example:

Realm: college-portal

Users: students, teachers

Roles: student, faculty, admin

Different realms do NOT share users or data.

2. Users
What is a user?
A user is a person who can log in.
A user has:
Username
Password
Email
Roles

Example:

Username: atharv

Email: atharv@college.edu

Role: student

Keycloak stores and verifies user credentials for you.

3. Roles
What is a role?

A role defines what a user is allowed to do.

Simple analogy:

Role = permission tag

Examples:

admin ‚Üí full access

teacher ‚Üí manage courses

student ‚Üí view content

Roles are later checked by your backend or frontend.

4. Login / Signup Configuration
What does this mean?

This controls how users log in or register.

You can configure:

Username + password login

Email verification

Forgot password

OTP / MFA

User self-registration (signup)

Password rules

Example:

Allow users to register themselves

Force strong passwords

Require email verification

Keycloak handles all login screens for you.

5. Connecting Applications (Frontend / Backend)
What does ‚Äúconnect an application‚Äù mean?

It means:

‚ÄúThis app will use Keycloak for login.‚Äù

In Keycloak, applications are called Clients.

Examples:

React frontend

Spring Boot backend

Mobile app

Each client gets:

Client ID

Security settings

Redirect URLs

6. OAuth2 / OpenID Connect
What are these?

They are standard login protocols.

You don‚Äôt need to invent login logic.

What they do:

OAuth2 ‚Üí authorization (access control)

OpenID Connect ‚Üí authentication (who the user is)

Simple flow:

User tries to log in

App redirects to Keycloak

User logs in

Keycloak sends back a token

App trusts the token

Keycloak fully implements these standards.

7. Authentication vs Authorization
Authentication

Who are you?

Username

Password

OTP

Handled by Keycloak.

Authorization

What are you allowed to do?

Roles

Permissions

Also managed by Keycloak.

SSO
SSO ensures that once you log in one time, you can access that application and all other connected applications without logging in again.
</file>

<file path="src/main/Theory/mapstruct.txt">
MapStruct is a Java library used to convert (map) one Java object into another automatically.
Why do we need MapStruct?

In real applications (especially Spring Boot), you often have:

Entity classes (database objects)

DTO classes (API request/response objects)

Example:

UserEntity ‚Üí UserDTO

OrderDTO ‚Üí OrderEntity

Without MapStruct, you would write repetitive code like:

UserDTO dto = new UserDTO();
dto.setId(entity.getId());
dto.setName(entity.getName());
dto.setEmail(entity.getEmail());

MapStruct is a compile-time Java mapper that automatically converts one object into another, replacing manual getter‚Äìsetter code.
</file>

<file path="src/main/Theory/OAuth2.txt">
OAuth 2.0 uses an external Authorization Server that authenticates the user and authorizes client and issues a JWT (access token) to a client application.
The Resource Server (another app) validates the JWT using the Authorization Server‚Äôs public key.
If the user does not exist in the application database, the application creates and stores a local user record based on the token claims.


User logs in at Authorization Server (Keycloak / Google)
Authorization Server authenticates user
Authorization Server issues JWT access token
Client (frontend) receives token
Client sends token to backend API
Backend API (Resource Server):
Validates JWT signature using public key
Validates expiry, issuer, audience
Backend checks DB:
User exists ‚Üí continue
User missing ‚Üí create user (provisioning)
Request is processed
</file>

<file path="src/main/Theory/Rest api architecture.md">
## Overview Of Rest API End Points

# Organiser

### Create Event

POST/api/v1/events

Request-Body:events

### List Events

GET/api/v1/events

### Retrieve a Specific Event

GET/api/v1/events/{event-id}

### Update Event

PUT/api/v1/event/{event-id}

Request-Body:events

### Delete Events

DELETE/api/v1/event/{event-id}

### Validate Tickets

POST/api/v1/events/{event-id}/ticket-validations

### List Ticket Validations

GET/api/v1/events/{event-id}/ticket-validations

### List Ticket Sales

GET/api/v1/events/{event-id}/tickets

### Retrieve Ticket Sales

GET/api/v1/events/{event-id}/tickets/{ticket-id}

### Partial Update  Ticket

Request-Body:Partial Ticket

### List Ticket Types                                                                   
                                                                                                    
GET/api/v1/event/{event-id}/ticket-types

### Retrieve Ticket Type

GET/api/v1/event/{event-id}/ticket-types /{ticket-type-id}

### Partial Update Ticket Type

### Delete Ticket Type

Delete/api/v1/event/{event-id}/ticket-types/{ticket-type-id}

# Attendee

### Landing Page : Browse all events

GET/api//v1/published-events

### Get the Specific Event

GET/api/v1/published-events/{published-event-id}

### Get the Ticket Types

### Purchase Ticket

POST/api/v1/published-events/{published-event-id}/{ticket-type}/{ticket_types-id}

### List Tickets Purchased By User

GET/api/v1/Tickets

### Retrieve Specific Ticket

Get/api/v1/Tickets/{ticket-id}

### Retrieve QR Code from Specific Ticket

Get/api/v1/Tickets/{ticket-id}/QR-code
</file>

<file path="src/main/Theory/userProvisioning.txt">
in this project we are using the keycloak as authentication and authorization server , so as  user does authentication , client gets th jwt token , but user is not recorded in applications's db , so if the user is not available in application's db are receiving the jwt to client , then we must record the user in db

if we were not using the kwycloak server , then first user is stored in db , then jwt is generated and given to client
</file>

<file path="src/test/java/com/atharv/Event_Ticket_Platform/EventTicketPlatformApplicationTests.java">
package com.atharv.Event_Ticket_Platform;

import org.junit.jupiter.api.Test;
import org.springframework.boot.test.context.SpringBootTest;

@SpringBootTest
class EventTicketPlatformApplicationTests {

	@Test
	void contextLoads() {
	}

}
</file>

<file path=".gitattributes">
/mvnw text eol=lf
*.cmd text eol=crlf
</file>

<file path=".gitignore">
HELP.md
target/
.mvn/wrapper/maven-wrapper.jar
!**/src/main/**/target/
!**/src/test/**/target/

### STS ###
.apt_generated
.classpath
.factorypath
.project
.settings
.springBeans
.sts4-cache

### IntelliJ IDEA ###
.idea
*.iws
*.iml
*.ipr

### NetBeans ###
/nbproject/private/
/nbbuild/
/dist/
/nbdist/
/.nb-gradle/
build/
!**/src/main/**/build/
!**/src/test/**/build/

### VS Code ###
.vscode/
</file>

<file path="docker-compose.yml">
services:
  # Our PostgreSQL database
  db:
    # Using the Latest PostgreSQL image
    image: postgres:latest
    ports:
      - "5432:5432"
    restart: always
    environment:
      POSTGRES_PASSWORD: changemeinprod!

  # Database management interface
  adminer:
    image: adminer:latest
    restart: always
    ports:
      - "8888:8080"

  keycloak:
    image: quay.io/keycloak/keycloak:latest
    ports:
      - "9090:8080"
    environment:
      KEYCLOAK_ADMIN: admin
      KEYCLOAK_ADMIN_PASSWORD: admin
    volumes:
      - keycloak-data:/opt/keycloak/data
    command:
      - start-dev
      - --db=dev-file

volumes:
  keycloak-data:
    driver: local
</file>

<file path="mvnw">
#!/bin/sh
# ----------------------------------------------------------------------------
# Licensed to the Apache Software Foundation (ASF) under one
# or more contributor license agreements.  See the NOTICE file
# distributed with this work for additional information
# regarding copyright ownership.  The ASF licenses this file
# to you under the Apache License, Version 2.0 (the
# "License"); you may not use this file except in compliance
# with the License.  You may obtain a copy of the License at
#
#    http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing,
# software distributed under the License is distributed on an
# "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
# KIND, either express or implied.  See the License for the
# specific language governing permissions and limitations
# under the License.
# ----------------------------------------------------------------------------

# ----------------------------------------------------------------------------
# Apache Maven Wrapper startup batch script, version 3.3.4
#
# Optional ENV vars
# -----------------
#   JAVA_HOME - location of a JDK home dir, required when download maven via java source
#   MVNW_REPOURL - repo url base for downloading maven distribution
#   MVNW_USERNAME/MVNW_PASSWORD - user and password for downloading maven
#   MVNW_VERBOSE - true: enable verbose log; debug: trace the mvnw script; others: silence the output
# ----------------------------------------------------------------------------

set -euf
[ "${MVNW_VERBOSE-}" != debug ] || set -x

# OS specific support.
native_path() { printf %s\\n "$1"; }
case "$(uname)" in
CYGWIN* | MINGW*)
  [ -z "${JAVA_HOME-}" ] || JAVA_HOME="$(cygpath --unix "$JAVA_HOME")"
  native_path() { cygpath --path --windows "$1"; }
  ;;
esac

# set JAVACMD and JAVACCMD
set_java_home() {
  # For Cygwin and MinGW, ensure paths are in Unix format before anything is touched
  if [ -n "${JAVA_HOME-}" ]; then
    if [ -x "$JAVA_HOME/jre/sh/java" ]; then
      # IBM's JDK on AIX uses strange locations for the executables
      JAVACMD="$JAVA_HOME/jre/sh/java"
      JAVACCMD="$JAVA_HOME/jre/sh/javac"
    else
      JAVACMD="$JAVA_HOME/bin/java"
      JAVACCMD="$JAVA_HOME/bin/javac"

      if [ ! -x "$JAVACMD" ] || [ ! -x "$JAVACCMD" ]; then
        echo "The JAVA_HOME environment variable is not defined correctly, so mvnw cannot run." >&2
        echo "JAVA_HOME is set to \"$JAVA_HOME\", but \"\$JAVA_HOME/bin/java\" or \"\$JAVA_HOME/bin/javac\" does not exist." >&2
        return 1
      fi
    fi
  else
    JAVACMD="$(
      'set' +e
      'unset' -f command 2>/dev/null
      'command' -v java
    )" || :
    JAVACCMD="$(
      'set' +e
      'unset' -f command 2>/dev/null
      'command' -v javac
    )" || :

    if [ ! -x "${JAVACMD-}" ] || [ ! -x "${JAVACCMD-}" ]; then
      echo "The java/javac command does not exist in PATH nor is JAVA_HOME set, so mvnw cannot run." >&2
      return 1
    fi
  fi
}

# hash string like Java String::hashCode
hash_string() {
  str="${1:-}" h=0
  while [ -n "$str" ]; do
    char="${str%"${str#?}"}"
    h=$(((h * 31 + $(LC_CTYPE=C printf %d "'$char")) % 4294967296))
    str="${str#?}"
  done
  printf %x\\n $h
}

verbose() { :; }
[ "${MVNW_VERBOSE-}" != true ] || verbose() { printf %s\\n "${1-}"; }

die() {
  printf %s\\n "$1" >&2
  exit 1
}

trim() {
  # MWRAPPER-139:
  #   Trims trailing and leading whitespace, carriage returns, tabs, and linefeeds.
  #   Needed for removing poorly interpreted newline sequences when running in more
  #   exotic environments such as mingw bash on Windows.
  printf "%s" "${1}" | tr -d '[:space:]'
}

scriptDir="$(dirname "$0")"
scriptName="$(basename "$0")"

# parse distributionUrl and optional distributionSha256Sum, requires .mvn/wrapper/maven-wrapper.properties
while IFS="=" read -r key value; do
  case "${key-}" in
  distributionUrl) distributionUrl=$(trim "${value-}") ;;
  distributionSha256Sum) distributionSha256Sum=$(trim "${value-}") ;;
  esac
done <"$scriptDir/.mvn/wrapper/maven-wrapper.properties"
[ -n "${distributionUrl-}" ] || die "cannot read distributionUrl property in $scriptDir/.mvn/wrapper/maven-wrapper.properties"

case "${distributionUrl##*/}" in
maven-mvnd-*bin.*)
  MVN_CMD=mvnd.sh _MVNW_REPO_PATTERN=/maven/mvnd/
  case "${PROCESSOR_ARCHITECTURE-}${PROCESSOR_ARCHITEW6432-}:$(uname -a)" in
  *AMD64:CYGWIN* | *AMD64:MINGW*) distributionPlatform=windows-amd64 ;;
  :Darwin*x86_64) distributionPlatform=darwin-amd64 ;;
  :Darwin*arm64) distributionPlatform=darwin-aarch64 ;;
  :Linux*x86_64*) distributionPlatform=linux-amd64 ;;
  *)
    echo "Cannot detect native platform for mvnd on $(uname)-$(uname -m), use pure java version" >&2
    distributionPlatform=linux-amd64
    ;;
  esac
  distributionUrl="${distributionUrl%-bin.*}-$distributionPlatform.zip"
  ;;
maven-mvnd-*) MVN_CMD=mvnd.sh _MVNW_REPO_PATTERN=/maven/mvnd/ ;;
*) MVN_CMD="mvn${scriptName#mvnw}" _MVNW_REPO_PATTERN=/org/apache/maven/ ;;
esac

# apply MVNW_REPOURL and calculate MAVEN_HOME
# maven home pattern: ~/.m2/wrapper/dists/{apache-maven-<version>,maven-mvnd-<version>-<platform>}/<hash>
[ -z "${MVNW_REPOURL-}" ] || distributionUrl="$MVNW_REPOURL$_MVNW_REPO_PATTERN${distributionUrl#*"$_MVNW_REPO_PATTERN"}"
distributionUrlName="${distributionUrl##*/}"
distributionUrlNameMain="${distributionUrlName%.*}"
distributionUrlNameMain="${distributionUrlNameMain%-bin}"
MAVEN_USER_HOME="${MAVEN_USER_HOME:-${HOME}/.m2}"
MAVEN_HOME="${MAVEN_USER_HOME}/wrapper/dists/${distributionUrlNameMain-}/$(hash_string "$distributionUrl")"

exec_maven() {
  unset MVNW_VERBOSE MVNW_USERNAME MVNW_PASSWORD MVNW_REPOURL || :
  exec "$MAVEN_HOME/bin/$MVN_CMD" "$@" || die "cannot exec $MAVEN_HOME/bin/$MVN_CMD"
}

if [ -d "$MAVEN_HOME" ]; then
  verbose "found existing MAVEN_HOME at $MAVEN_HOME"
  exec_maven "$@"
fi

case "${distributionUrl-}" in
*?-bin.zip | *?maven-mvnd-?*-?*.zip) ;;
*) die "distributionUrl is not valid, must match *-bin.zip or maven-mvnd-*.zip, but found '${distributionUrl-}'" ;;
esac

# prepare tmp dir
if TMP_DOWNLOAD_DIR="$(mktemp -d)" && [ -d "$TMP_DOWNLOAD_DIR" ]; then
  clean() { rm -rf -- "$TMP_DOWNLOAD_DIR"; }
  trap clean HUP INT TERM EXIT
else
  die "cannot create temp dir"
fi

mkdir -p -- "${MAVEN_HOME%/*}"

# Download and Install Apache Maven
verbose "Couldn't find MAVEN_HOME, downloading and installing it ..."
verbose "Downloading from: $distributionUrl"
verbose "Downloading to: $TMP_DOWNLOAD_DIR/$distributionUrlName"

# select .zip or .tar.gz
if ! command -v unzip >/dev/null; then
  distributionUrl="${distributionUrl%.zip}.tar.gz"
  distributionUrlName="${distributionUrl##*/}"
fi

# verbose opt
__MVNW_QUIET_WGET=--quiet __MVNW_QUIET_CURL=--silent __MVNW_QUIET_UNZIP=-q __MVNW_QUIET_TAR=''
[ "${MVNW_VERBOSE-}" != true ] || __MVNW_QUIET_WGET='' __MVNW_QUIET_CURL='' __MVNW_QUIET_UNZIP='' __MVNW_QUIET_TAR=v

# normalize http auth
case "${MVNW_PASSWORD:+has-password}" in
'') MVNW_USERNAME='' MVNW_PASSWORD='' ;;
has-password) [ -n "${MVNW_USERNAME-}" ] || MVNW_USERNAME='' MVNW_PASSWORD='' ;;
esac

if [ -z "${MVNW_USERNAME-}" ] && command -v wget >/dev/null; then
  verbose "Found wget ... using wget"
  wget ${__MVNW_QUIET_WGET:+"$__MVNW_QUIET_WGET"} "$distributionUrl" -O "$TMP_DOWNLOAD_DIR/$distributionUrlName" || die "wget: Failed to fetch $distributionUrl"
elif [ -z "${MVNW_USERNAME-}" ] && command -v curl >/dev/null; then
  verbose "Found curl ... using curl"
  curl ${__MVNW_QUIET_CURL:+"$__MVNW_QUIET_CURL"} -f -L -o "$TMP_DOWNLOAD_DIR/$distributionUrlName" "$distributionUrl" || die "curl: Failed to fetch $distributionUrl"
elif set_java_home; then
  verbose "Falling back to use Java to download"
  javaSource="$TMP_DOWNLOAD_DIR/Downloader.java"
  targetZip="$TMP_DOWNLOAD_DIR/$distributionUrlName"
  cat >"$javaSource" <<-END
	public class Downloader extends java.net.Authenticator
	{
	  protected java.net.PasswordAuthentication getPasswordAuthentication()
	  {
	    return new java.net.PasswordAuthentication( System.getenv( "MVNW_USERNAME" ), System.getenv( "MVNW_PASSWORD" ).toCharArray() );
	  }
	  public static void main( String[] args ) throws Exception
	  {
	    setDefault( new Downloader() );
	    java.nio.file.Files.copy( java.net.URI.create( args[0] ).toURL().openStream(), java.nio.file.Paths.get( args[1] ).toAbsolutePath().normalize() );
	  }
	}
	END
  # For Cygwin/MinGW, switch paths to Windows format before running javac and java
  verbose " - Compiling Downloader.java ..."
  "$(native_path "$JAVACCMD")" "$(native_path "$javaSource")" || die "Failed to compile Downloader.java"
  verbose " - Running Downloader.java ..."
  "$(native_path "$JAVACMD")" -cp "$(native_path "$TMP_DOWNLOAD_DIR")" Downloader "$distributionUrl" "$(native_path "$targetZip")"
fi

# If specified, validate the SHA-256 sum of the Maven distribution zip file
if [ -n "${distributionSha256Sum-}" ]; then
  distributionSha256Result=false
  if [ "$MVN_CMD" = mvnd.sh ]; then
    echo "Checksum validation is not supported for maven-mvnd." >&2
    echo "Please disable validation by removing 'distributionSha256Sum' from your maven-wrapper.properties." >&2
    exit 1
  elif command -v sha256sum >/dev/null; then
    if echo "$distributionSha256Sum  $TMP_DOWNLOAD_DIR/$distributionUrlName" | sha256sum -c - >/dev/null 2>&1; then
      distributionSha256Result=true
    fi
  elif command -v shasum >/dev/null; then
    if echo "$distributionSha256Sum  $TMP_DOWNLOAD_DIR/$distributionUrlName" | shasum -a 256 -c >/dev/null 2>&1; then
      distributionSha256Result=true
    fi
  else
    echo "Checksum validation was requested but neither 'sha256sum' or 'shasum' are available." >&2
    echo "Please install either command, or disable validation by removing 'distributionSha256Sum' from your maven-wrapper.properties." >&2
    exit 1
  fi
  if [ $distributionSha256Result = false ]; then
    echo "Error: Failed to validate Maven distribution SHA-256, your Maven distribution might be compromised." >&2
    echo "If you updated your Maven version, you need to update the specified distributionSha256Sum property." >&2
    exit 1
  fi
fi

# unzip and move
if command -v unzip >/dev/null; then
  unzip ${__MVNW_QUIET_UNZIP:+"$__MVNW_QUIET_UNZIP"} "$TMP_DOWNLOAD_DIR/$distributionUrlName" -d "$TMP_DOWNLOAD_DIR" || die "failed to unzip"
else
  tar xzf${__MVNW_QUIET_TAR:+"$__MVNW_QUIET_TAR"} "$TMP_DOWNLOAD_DIR/$distributionUrlName" -C "$TMP_DOWNLOAD_DIR" || die "failed to untar"
fi

# Find the actual extracted directory name (handles snapshots where filename != directory name)
actualDistributionDir=""

# First try the expected directory name (for regular distributions)
if [ -d "$TMP_DOWNLOAD_DIR/$distributionUrlNameMain" ]; then
  if [ -f "$TMP_DOWNLOAD_DIR/$distributionUrlNameMain/bin/$MVN_CMD" ]; then
    actualDistributionDir="$distributionUrlNameMain"
  fi
fi

# If not found, search for any directory with the Maven executable (for snapshots)
if [ -z "$actualDistributionDir" ]; then
  # enable globbing to iterate over items
  set +f
  for dir in "$TMP_DOWNLOAD_DIR"/*; do
    if [ -d "$dir" ]; then
      if [ -f "$dir/bin/$MVN_CMD" ]; then
        actualDistributionDir="$(basename "$dir")"
        break
      fi
    fi
  done
  set -f
fi

if [ -z "$actualDistributionDir" ]; then
  verbose "Contents of $TMP_DOWNLOAD_DIR:"
  verbose "$(ls -la "$TMP_DOWNLOAD_DIR")"
  die "Could not find Maven distribution directory in extracted archive"
fi

verbose "Found extracted Maven distribution directory: $actualDistributionDir"
printf %s\\n "$distributionUrl" >"$TMP_DOWNLOAD_DIR/$actualDistributionDir/mvnw.url"
mv -- "$TMP_DOWNLOAD_DIR/$actualDistributionDir" "$MAVEN_HOME" || [ -d "$MAVEN_HOME" ] || die "fail to move MAVEN_HOME"

clean || :
exec_maven "$@"
</file>

<file path="mvnw.cmd">
<# : batch portion
@REM ----------------------------------------------------------------------------
@REM Licensed to the Apache Software Foundation (ASF) under one
@REM or more contributor license agreements.  See the NOTICE file
@REM distributed with this work for additional information
@REM regarding copyright ownership.  The ASF licenses this file
@REM to you under the Apache License, Version 2.0 (the
@REM "License"); you may not use this file except in compliance
@REM with the License.  You may obtain a copy of the License at
@REM
@REM    http://www.apache.org/licenses/LICENSE-2.0
@REM
@REM Unless required by applicable law or agreed to in writing,
@REM software distributed under the License is distributed on an
@REM "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
@REM KIND, either express or implied.  See the License for the
@REM specific language governing permissions and limitations
@REM under the License.
@REM ----------------------------------------------------------------------------

@REM ----------------------------------------------------------------------------
@REM Apache Maven Wrapper startup batch script, version 3.3.4
@REM
@REM Optional ENV vars
@REM   MVNW_REPOURL - repo url base for downloading maven distribution
@REM   MVNW_USERNAME/MVNW_PASSWORD - user and password for downloading maven
@REM   MVNW_VERBOSE - true: enable verbose log; others: silence the output
@REM ----------------------------------------------------------------------------

@IF "%__MVNW_ARG0_NAME__%"=="" (SET __MVNW_ARG0_NAME__=%~nx0)
@SET __MVNW_CMD__=
@SET __MVNW_ERROR__=
@SET __MVNW_PSMODULEP_SAVE=%PSModulePath%
@SET PSModulePath=
@FOR /F "usebackq tokens=1* delims==" %%A IN (`powershell -noprofile "& {$scriptDir='%~dp0'; $script='%__MVNW_ARG0_NAME__%'; icm -ScriptBlock ([Scriptblock]::Create((Get-Content -Raw '%~f0'))) -NoNewScope}"`) DO @(
  IF "%%A"=="MVN_CMD" (set __MVNW_CMD__=%%B) ELSE IF "%%B"=="" (echo %%A) ELSE (echo %%A=%%B)
)
@SET PSModulePath=%__MVNW_PSMODULEP_SAVE%
@SET __MVNW_PSMODULEP_SAVE=
@SET __MVNW_ARG0_NAME__=
@SET MVNW_USERNAME=
@SET MVNW_PASSWORD=
@IF NOT "%__MVNW_CMD__%"=="" ("%__MVNW_CMD__%" %*)
@echo Cannot start maven from wrapper >&2 && exit /b 1
@GOTO :EOF
: end batch / begin powershell #>

$ErrorActionPreference = "Stop"
if ($env:MVNW_VERBOSE -eq "true") {
  $VerbosePreference = "Continue"
}

# calculate distributionUrl, requires .mvn/wrapper/maven-wrapper.properties
$distributionUrl = (Get-Content -Raw "$scriptDir/.mvn/wrapper/maven-wrapper.properties" | ConvertFrom-StringData).distributionUrl
if (!$distributionUrl) {
  Write-Error "cannot read distributionUrl property in $scriptDir/.mvn/wrapper/maven-wrapper.properties"
}

switch -wildcard -casesensitive ( $($distributionUrl -replace '^.*/','') ) {
  "maven-mvnd-*" {
    $USE_MVND = $true
    $distributionUrl = $distributionUrl -replace '-bin\.[^.]*$',"-windows-amd64.zip"
    $MVN_CMD = "mvnd.cmd"
    break
  }
  default {
    $USE_MVND = $false
    $MVN_CMD = $script -replace '^mvnw','mvn'
    break
  }
}

# apply MVNW_REPOURL and calculate MAVEN_HOME
# maven home pattern: ~/.m2/wrapper/dists/{apache-maven-<version>,maven-mvnd-<version>-<platform>}/<hash>
if ($env:MVNW_REPOURL) {
  $MVNW_REPO_PATTERN = if ($USE_MVND -eq $False) { "/org/apache/maven/" } else { "/maven/mvnd/" }
  $distributionUrl = "$env:MVNW_REPOURL$MVNW_REPO_PATTERN$($distributionUrl -replace "^.*$MVNW_REPO_PATTERN",'')"
}
$distributionUrlName = $distributionUrl -replace '^.*/',''
$distributionUrlNameMain = $distributionUrlName -replace '\.[^.]*$','' -replace '-bin$',''

$MAVEN_M2_PATH = "$HOME/.m2"
if ($env:MAVEN_USER_HOME) {
  $MAVEN_M2_PATH = "$env:MAVEN_USER_HOME"
}

if (-not (Test-Path -Path $MAVEN_M2_PATH)) {
    New-Item -Path $MAVEN_M2_PATH -ItemType Directory | Out-Null
}

$MAVEN_WRAPPER_DISTS = $null
if ((Get-Item $MAVEN_M2_PATH).Target[0] -eq $null) {
  $MAVEN_WRAPPER_DISTS = "$MAVEN_M2_PATH/wrapper/dists"
} else {
  $MAVEN_WRAPPER_DISTS = (Get-Item $MAVEN_M2_PATH).Target[0] + "/wrapper/dists"
}

$MAVEN_HOME_PARENT = "$MAVEN_WRAPPER_DISTS/$distributionUrlNameMain"
$MAVEN_HOME_NAME = ([System.Security.Cryptography.SHA256]::Create().ComputeHash([byte[]][char[]]$distributionUrl) | ForEach-Object {$_.ToString("x2")}) -join ''
$MAVEN_HOME = "$MAVEN_HOME_PARENT/$MAVEN_HOME_NAME"

if (Test-Path -Path "$MAVEN_HOME" -PathType Container) {
  Write-Verbose "found existing MAVEN_HOME at $MAVEN_HOME"
  Write-Output "MVN_CMD=$MAVEN_HOME/bin/$MVN_CMD"
  exit $?
}

if (! $distributionUrlNameMain -or ($distributionUrlName -eq $distributionUrlNameMain)) {
  Write-Error "distributionUrl is not valid, must end with *-bin.zip, but found $distributionUrl"
}

# prepare tmp dir
$TMP_DOWNLOAD_DIR_HOLDER = New-TemporaryFile
$TMP_DOWNLOAD_DIR = New-Item -Itemtype Directory -Path "$TMP_DOWNLOAD_DIR_HOLDER.dir"
$TMP_DOWNLOAD_DIR_HOLDER.Delete() | Out-Null
trap {
  if ($TMP_DOWNLOAD_DIR.Exists) {
    try { Remove-Item $TMP_DOWNLOAD_DIR -Recurse -Force | Out-Null }
    catch { Write-Warning "Cannot remove $TMP_DOWNLOAD_DIR" }
  }
}

New-Item -Itemtype Directory -Path "$MAVEN_HOME_PARENT" -Force | Out-Null

# Download and Install Apache Maven
Write-Verbose "Couldn't find MAVEN_HOME, downloading and installing it ..."
Write-Verbose "Downloading from: $distributionUrl"
Write-Verbose "Downloading to: $TMP_DOWNLOAD_DIR/$distributionUrlName"

$webclient = New-Object System.Net.WebClient
if ($env:MVNW_USERNAME -and $env:MVNW_PASSWORD) {
  $webclient.Credentials = New-Object System.Net.NetworkCredential($env:MVNW_USERNAME, $env:MVNW_PASSWORD)
}
[Net.ServicePointManager]::SecurityProtocol = [Net.SecurityProtocolType]::Tls12
$webclient.DownloadFile($distributionUrl, "$TMP_DOWNLOAD_DIR/$distributionUrlName") | Out-Null

# If specified, validate the SHA-256 sum of the Maven distribution zip file
$distributionSha256Sum = (Get-Content -Raw "$scriptDir/.mvn/wrapper/maven-wrapper.properties" | ConvertFrom-StringData).distributionSha256Sum
if ($distributionSha256Sum) {
  if ($USE_MVND) {
    Write-Error "Checksum validation is not supported for maven-mvnd. `nPlease disable validation by removing 'distributionSha256Sum' from your maven-wrapper.properties."
  }
  Import-Module $PSHOME\Modules\Microsoft.PowerShell.Utility -Function Get-FileHash
  if ((Get-FileHash "$TMP_DOWNLOAD_DIR/$distributionUrlName" -Algorithm SHA256).Hash.ToLower() -ne $distributionSha256Sum) {
    Write-Error "Error: Failed to validate Maven distribution SHA-256, your Maven distribution might be compromised. If you updated your Maven version, you need to update the specified distributionSha256Sum property."
  }
}

# unzip and move
Expand-Archive "$TMP_DOWNLOAD_DIR/$distributionUrlName" -DestinationPath "$TMP_DOWNLOAD_DIR" | Out-Null

# Find the actual extracted directory name (handles snapshots where filename != directory name)
$actualDistributionDir = ""

# First try the expected directory name (for regular distributions)
$expectedPath = Join-Path "$TMP_DOWNLOAD_DIR" "$distributionUrlNameMain"
$expectedMvnPath = Join-Path "$expectedPath" "bin/$MVN_CMD"
if ((Test-Path -Path $expectedPath -PathType Container) -and (Test-Path -Path $expectedMvnPath -PathType Leaf)) {
  $actualDistributionDir = $distributionUrlNameMain
}

# If not found, search for any directory with the Maven executable (for snapshots)
if (!$actualDistributionDir) {
  Get-ChildItem -Path "$TMP_DOWNLOAD_DIR" -Directory | ForEach-Object {
    $testPath = Join-Path $_.FullName "bin/$MVN_CMD"
    if (Test-Path -Path $testPath -PathType Leaf) {
      $actualDistributionDir = $_.Name
    }
  }
}

if (!$actualDistributionDir) {
  Write-Error "Could not find Maven distribution directory in extracted archive"
}

Write-Verbose "Found extracted Maven distribution directory: $actualDistributionDir"
Rename-Item -Path "$TMP_DOWNLOAD_DIR/$actualDistributionDir" -NewName $MAVEN_HOME_NAME | Out-Null
try {
  Move-Item -Path "$TMP_DOWNLOAD_DIR/$MAVEN_HOME_NAME" -Destination $MAVEN_HOME_PARENT | Out-Null
} catch {
  if (! (Test-Path -Path "$MAVEN_HOME" -PathType Container)) {
    Write-Error "fail to move MAVEN_HOME"
  }
} finally {
  try { Remove-Item $TMP_DOWNLOAD_DIR -Recurse -Force | Out-Null }
  catch { Write-Warning "Cannot remove $TMP_DOWNLOAD_DIR" }
}

Write-Output "MVN_CMD=$MAVEN_HOME/bin/$MVN_CMD"
</file>

<file path="pom.xml">
<?xml version="1.0" encoding="UTF-8"?>
<project xmlns="http://maven.apache.org/POM/4.0.0"
         xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
         xsi:schemaLocation="http://maven.apache.org/POM/4.0.0
                             https://maven.apache.org/xsd/maven-4.0.0.xsd">

    <modelVersion>4.0.0</modelVersion>

    <!-- Spring Boot Parent -->
    <parent>
        <groupId>org.springframework.boot</groupId>
        <artifactId>spring-boot-starter-parent</artifactId>
        <version>3.5.7</version>
        <relativePath/>
    </parent>

    <groupId>com.atharv</groupId>
    <artifactId>Event-Ticket-Platform</artifactId>
    <version>0.0.1-SNAPSHOT</version>
    <name>Event-Ticket-Platform</name>
    <description>Event Ticket Platform</description>

    <!-- Java & Tooling Versions -->
    <properties>
        <java.version>21</java.version>
        <org.mapstruct.version>1.6.3</org.mapstruct.version>
        <lombok.version>1.18.36</lombok.version>
        <lombok-mapstruct-binding.version>0.2.0</lombok-mapstruct-binding.version>
        <zxing.version>3.5.3</zxing.version>
    </properties>

    <!-- Dependencies -->
    <dependencies>

        <!-- Spring Boot Core -->
        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter-web</artifactId>
        </dependency>

        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter-data-jpa</artifactId>
        </dependency>

        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter-security</artifactId>
        </dependency>

        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter-oauth2-resource-server</artifactId>
        </dependency>

        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter-validation</artifactId>
        </dependency>

        <!-- Database -->
        <dependency>
            <groupId>org.postgresql</groupId>
            <artifactId>postgresql</artifactId>
            <scope>runtime</scope>
        </dependency>

        <dependency>
            <groupId>com.h2database</groupId>
            <artifactId>h2</artifactId>
            <scope>test</scope>
        </dependency>

        <!-- Lombok -->
        <dependency>
            <groupId>org.projectlombok</groupId>
            <artifactId>lombok</artifactId>
            <version>${lombok.version}</version>
            <optional>true</optional>
        </dependency>

        <!-- MapStruct -->
        <dependency>
            <groupId>org.mapstruct</groupId>
            <artifactId>mapstruct</artifactId>
            <version>${org.mapstruct.version}</version>
        </dependency>

        <!-- ZXing (QR Code Generation) -->
        <dependency>
            <groupId>com.google.zxing</groupId>
            <artifactId>core</artifactId>
            <version>${zxing.version}</version>
        </dependency>

        <dependency>
            <groupId>com.google.zxing</groupId>
            <artifactId>javase</artifactId>
            <version>${zxing.version}</version>
        </dependency>

        <!-- Keycloak Admin Client -->
        <dependency>
            <groupId>org.keycloak</groupId>
            <artifactId>keycloak-admin-client</artifactId>
            <version>23.0.7</version>
        </dependency>

        <!-- Required for Keycloak Admin Client -->
        <dependency>
            <groupId>org.jboss.resteasy</groupId>
            <artifactId>resteasy-client</artifactId>
            <version>6.2.7.Final</version>
        </dependency>

        <dependency>
            <groupId>org.jboss.resteasy</groupId>
            <artifactId>resteasy-jackson2-provider</artifactId>
            <version>6.2.7.Final</version>
        </dependency>

        <!-- Testing -->
        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter-test</artifactId>
            <scope>test</scope>
        </dependency>

        <dependency>
            <groupId>org.springframework.security</groupId>
            <artifactId>spring-security-test</artifactId>
            <scope>test</scope>
        </dependency>

    </dependencies>

    <!-- Build Configuration -->
    <build>
        <plugins>

            <!-- Compiler & Annotation Processing -->
            <plugin>
                <groupId>org.apache.maven.plugins</groupId>
                <artifactId>maven-compiler-plugin</artifactId>
                <version>3.13.0</version>
                <configuration>
                    <source>${java.version}</source>
                    <target>${java.version}</target>
                    <annotationProcessorPaths>
                        <path>
                            <groupId>org.projectlombok</groupId>
                            <artifactId>lombok</artifactId>
                            <version>${lombok.version}</version>
                        </path>
                        <path>
                            <groupId>org.mapstruct</groupId>
                            <artifactId>mapstruct-processor</artifactId>
                            <version>${org.mapstruct.version}</version>
                        </path>
                        <path>
                            <groupId>org.projectlombok</groupId>
                            <artifactId>lombok-mapstruct-binding</artifactId>
                            <version>${lombok-mapstruct-binding.version}</version>
                        </path>
                    </annotationProcessorPaths>
                </configuration>
            </plugin>

            <!-- Spring Boot Plugin -->
            <plugin>
                <groupId>org.springframework.boot</groupId>
                <artifactId>spring-boot-maven-plugin</artifactId>
                <configuration>
                    <excludes>
                        <exclude>
                            <groupId>org.projectlombok</groupId>
                            <artifactId>lombok</artifactId>
                        </exclude>
                    </excludes>
                </configuration>
            </plugin>

        </plugins>
    </build>

</project>
</file>

</files>
